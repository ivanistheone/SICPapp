<div class="navbar" align="center">
<a class="link" onclick="window.displayManager.show('section_1_2.html')">previous section</a>&nbsp;&nbsp;&nbsp;<a class="link" onclick="window.displayManager.show('chapter_1.html')">this chapter</a>&nbsp;&nbsp;&nbsp;<hr>
</div><h2><a name="section_1_3">1.3&nbsp;
        Formulating Abstractions with Higher-Order 
        Functions
      </a></h2>
      

      <div class="subtoc">
<strong>In this section</strong><p></p>
<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#subsection_1_3_1">1.3.1&nbsp;
          Functions
          as Arguments
        </a><br><a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#subsection_1_3_2">1.3.2&nbsp;
          Function Definition Expressions
          </a><br><a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#subsection_1_3_3">1.3.3&nbsp;
            Functions
            as General Methods
          </a><br><a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#subsection_1_3_4">1.3.4&nbsp;
              Functions
              as Returned Values
            </a><br>
</div>

      <a name="sec:higher-order-procedures"></a>

      <div class="normaltext">
        We have seen that
        functions
        are, in effect, abstractions that describe
        compound operations on numbers independent of the particular numbers.
        For example, when we
        <div style="position:absolute;display:none;" id="javascript_252_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction cube(x) {\n   return x * x * x;\n}\n\n// example\n\ncube(3);','javascript_252','',event,1.0);">function cube(x) {
   return x * x * x;
}</pre>

        
        
        we are not talking about the cube of a particular number, but rather
        about a method for obtaining the cube of any number.  Of course we
        could get along without ever defining this
        function, by
        always writing expressions such as
        <form name="form_254" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_254.png"></form>
        and never mentioning <span class="schemeinline">cube</span> explicitly.  
        This would place us at a
        serious disadvantage, forcing us to work always at the level of the
        particular operations that happen to be primitives in the language
        (multiplication, in this case) rather than in terms of higher-level
        operations.  Our programs would be able to compute cubes, but our
        language would lack the ability to express the concept of cubing.  One
        of the things we should demand from a powerful programming language is
        the ability to build abstractions by assigning names to common
        patterns and then to work in terms of the abstractions directly.
        Functions
        provide this ability.  This is why all but the most
        primitive programming languages include mechanisms for defining
        functions.
      </div>
      <div class="normaltext">
        Yet even in numerical processing we will be severely limited in our
        ability to create abstractions if we are restricted to
        functions
        whose parameters must be numbers.  Often the same programming pattern
        will be used with a number of different
        functions.  To express such
        patterns as concepts, we will need to construct
        functions
        that can
        accept
        functions
        as arguments or return
        functions
        as values.
        Functions
        that manipulate
        functions
        are called 
        
        <em>higher-order
          functions</em>.  This section shows how higher-order
        functions
        can serve
        as powerful abstraction mechanisms, vastly increasing the expressive
        power of our language.
      </div>

      <h3><a name="subsection_1_3_1">1.3.1&nbsp;
          Functions
          as Arguments
        </a></h3>
        

        <a name="sec:procedures-as-parameters"></a>
        
        

        <div class="normaltext">
          Consider the following three
          functions.  The first computes the sum
          of the integers from <span class="schemeinline">a</span> through <span class="schemeinline">b</span>:
        <div style="position:absolute;display:none;" id="javascript_255_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction sum_integers(a,b) {\n   if (a &gt; b)\n        return 0;\n   else return a + sum_integers(a + 1,b);\n}\n\n// example\n\nsum_integers(1,10);','javascript_255','',event,1.0);">function sum_integers(a,b) {
   if (a &gt; b)
        return 0;
   else return a + sum_integers(a + 1,b);
}</pre>
        
        The second computes the sum of the cubes of the integers in the given range:
        <div style="position:absolute;display:none;" id="javascript_256_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction cube(x) {\n   return x * x * x;\n}\n          \nfunction sum_cubes(a,b) {\n   if (a &gt; b)\n        return 0;\n   else return cube(a) + sum_cubes(a + 1,b);\n}\n\n// example\n\nsum_cubes(3,7);','javascript_256','',event,1.0);">function sum_cubes(a,b) {
   if (a &gt; b)
        return 0;
   else return cube(a) + sum_cubes(a + 1,b);
}</pre>
              
        
          The third computes the sum of a sequence of terms in the
          series
          <P><img src="img_javascript/latex_25.png"></P>
          which converges to <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_449.png"></span> 
          (very slowly):<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_1"><a class="link" href="#footnote_1">1</a></a></span>
          
        <div style="position:absolute;display:none;" id="javascript_258_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction pi_sum(a,b) {\n   if (a &gt; b)\n        return 0;\n   else return 1.0 / (a * (a + 2)) + \n               pi_sum(a + 4,b);\n}\n\n// example\n\n8 * pi_sum(1,1000);','javascript_258','',event,1.0);">function pi_sum(a,b) {
   if (a &gt; b)
        return 0;
   else return 1.0 / (a * (a + 2)) + 
               pi_sum(a + 4,b);
}</pre>
        </div>
        <div class="normaltext">
          These three
          functions
          clearly share a common underlying pattern.
          They are for the most part identical, differing only in the name of
          the
          function, the function of <span class="schemeinline">a</span> used to compute the term to be added,
          and the function that provides the next value of <span class="schemeinline">a</span>.  We could generate
          each of the
          functions
          by filling in slots in the same template:

          <form name="form_259" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_259.png"></form>
        </div>

        <div class="normaltext">
          
          The presence of such a common pattern is strong evidence that there is
          a useful abstraction waiting to be brought to the surface.  Indeed,
          mathematicians long ago identified the abstraction of
          
          <em>summation of a series</em> and invented &#147;sigma
            
            
            notation,&#148; for example
          <P><img src="img_javascript/latex_26.png"></P>
          to express this concept.  The power of sigma notation is that it
          allows mathematicians to deal with the concept of summation
          itself rather than only with particular sums—for example, to
          formulate general results about sums that are independent of the
          particular series being summed.
        </div>

        <div class="normaltext">
          Similarly, as program designers, we would like our language to
          be powerful enough so that we can write a
          function
          that expresses the
          concept of summation itself rather than only
          functions
          that compute particular sums.  We can do so readily in our
          functional
          language by taking the common template shown above and
          transforming the &#147;slots&#148; into formal parameters:

        <div style="position:absolute;display:none;" id="javascript_260_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction sum(term,a,next,b) {\n   if (a &gt; b)\n        return 0;\n   else return term(a) + \n               sum(term,next(a),next,b);\n}','javascript_260','',event,1.0);">function sum(term,a,next,b) {
   if (a &gt; b)
        return 0;
   else return term(a) + 
               sum(term,next(a),next,b);
}</pre>
              
        </div>
        <div class="normaltext">
          Notice that <span class="schemeinline">sum</span> takes as its arguments the lower and upper bounds
          <span class="schemeinline">a</span>&nbsp;and&nbsp;<span class="schemeinline">b</span> together with the
          functions
          <span class="schemeinline">term</span> and <span class="schemeinline">next</span>.
          We can use <span class="schemeinline">sum</span> just as we would any
          function.  For example, we can
          use it (along with a
          function
          <span class="schemeinline">inc</span> that increments its argument by 1)
          to define <span class="javascriptinline">sum_cubes</span>:
        
              
              

        <div style="position:absolute;display:none;" id="javascript_262_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction cube(x) {\n   return x * x * x;\n}\n          \nfunction sum(term,a,next,b) {\n   if (a &gt; b)\n        return 0;\n   else return term(a) + \n               sum(term,next(a),next,b);\n}\n          \nfunction inc(n) {\n   return n + 1;\n}\n          \nfunction inc(n) {\n   return n + 1;\n}\nfunction sum_cubes(a,b) {\n   return sum(cube,a,inc,b);\n}\n\n// example\n\nsum_cubes(1,10);','javascript_262','',event,1.0);">function inc(n) {
   return n + 1;
}
function sum_cubes(a,b) {
   return sum(cube,a,inc,b);
}</pre>
        </div>

        <div class="normaltext">
          Using this, we can compute the sum of the cubes of the integers from 1
          to 10:

        
        </div>

        <div class="normaltext">
          With the aid of an identity
          function
          to compute the term, we can define
          <span class="javascriptinline">sum_integers</span>
          in terms of <span class="schemeinline">sum</span>:

          
          

        <div style="position:absolute;display:none;" id="javascript_264_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction identity(x) {\n   return x;\n}\n\n// example\n\nidentity(42);','javascript_264','',event,1.0);">function identity(x) {
   return x;
}</pre>

        

        <div style="position:absolute;display:none;" id="javascript_266_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction sum(term,a,next,b) {\n   if (a &gt; b)\n        return 0;\n   else return term(a) + \n               sum(term,next(a),next,b);\n}\n          \nfunction inc(n) {\n   return n + 1;\n}\n          \nfunction identity(x) {\n   return x;\n}\n          \nfunction sum_integers(a,b) {\n   return sum(identity,a,inc,b);\n}\n\n// example\n\nsum_integers(1,10);','javascript_266','',event,1.0);">function sum_integers(a,b) {
   return sum(identity,a,inc,b);
}</pre>

          Then we can add up the integers from 1 to 10:
        <div style="position:absolute;display:none;" id="javascript_267_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction sum(term,a,next,b) {\n   if (a &gt; b)\n        return 0;\n   else return term(a) + \n               sum(term,next(a),next,b);\n}\n          \nfunction inc(n) {\n   return n + 1;\n}\n          \nfunction identity(x) {\n   return x;\n}\n          \nfunction sum_integers(a,b) {\n   return sum(identity,a,inc,b);\n}\n          \nsum_integers(1,10);','javascript_267','',event,1.0);">sum_integers(1,10);</pre>
        </div>

        <div class="normaltext">
          We can also define 
          <span class="javascriptinline">pi_sum</span>
          in the same way:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_2"><a class="link" href="#footnote_2">2</a></a></span>

              

        <div style="position:absolute;display:none;" id="javascript_268_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction sum(term,a,next,b) {\n   if (a &gt; b)\n        return 0;\n   else return term(a) + \n               sum(term,next(a),next,b);\n}\n          \nfunction pi_sum(a,b) {\n   function pi_term(x) {\n      return 1.0 / (x * (x + 2));\n   }\n   function pi_next(x) {\n      return x + 4;\n   }\n   return sum(pi_term,a,pi_next,b);\n}\n\n// example\n\n8 * pi_sum(1,1000);','javascript_268','',event,1.0);">function pi_sum(a,b) {
   function pi_term(x) {
      return 1.0 / (x * (x + 2));
   }
   function pi_next(x) {
      return x + 4;
   }
   return sum(pi_term,a,pi_next,b);
}</pre>

        </div>

        <div class="normaltext">
          Using these
          functions, we can compute an approximation to 
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_455.png"></span>:

        <div style="position:absolute;display:none;" id="javascript_269_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction sum(term,a,next,b) {\n   if (a &gt; b)\n        return 0;\n   else return term(a) + \n               sum(term,next(a),next,b);\n}\n          \nfunction pi_sum(a,b) {\n   function pi_term(x) {\n      return 1.0 / (x * (x + 2));\n   }\n   function pi_next(x) {\n      return x + 4;\n   }\n   return sum(pi_term,a,pi_next,b);\n}\n          \n8 * pi_sum(1,1000);','javascript_269','',event,1.0);">8 * pi_sum(1,1000);</pre>
        </div>

        <div class="normaltext">
          Once we have <span class="schemeinline">sum</span>, we can use it as a building block in
          formulating further concepts.  For instance, the 
          
          definite integral of a
          function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_456.png"></span> between the limits 
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_457.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_458.png"></span> can be approximated
          numerically using the formula
          <P><img src="img_javascript/latex_27.png"></P>
          for small values of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_459.png"></span>.  
          We can express this directly as a
          function:

          
        <div style="position:absolute;display:none;" id="javascript_270_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction sum(term,a,next,b) {\n   if (a &gt; b)\n        return 0;\n   else return term(a) + \n               sum(term,next(a),next,b);\n}\n          \nfunction integral(f,a,b,dx) {\n   function add_dx(x) {\n      return x + dx;\n   }\n   return sum(f,a + dx / 2,add_dx,b) * dx;\n}','javascript_270','',event,1.0);">function integral(f,a,b,dx) {
   function add_dx(x) {
      return x + dx;
   }
   return sum(f,a + dx / 2,add_dx,b) * dx;
}</pre>

        <div style="position:absolute;display:none;" id="javascript_271_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction sum(term,a,next,b) {\n   if (a &gt; b)\n        return 0;\n   else return term(a) + \n               sum(term,next(a),next,b);\n}\n          \nfunction integral(f,a,b,dx) {\n   function add_dx(x) {\n      return x + dx;\n   }\n   return sum(f,a + dx / 2,add_dx,b) * dx;\n}\n          \nfunction cube(x) {\n   return x * x * x;\n}\n          \nintegral(cube,0,1,0.01);','javascript_271','',event,1.0);">integral(cube,0,1,0.01);</pre>

        <div style="position:absolute;display:none;" id="javascript_272_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction sum(term,a,next,b) {\n   if (a &gt; b)\n        return 0;\n   else return term(a) + \n               sum(term,next(a),next,b);\n}\n          \nfunction integral(f,a,b,dx) {\n   function add_dx(x) {\n      return x + dx;\n   }\n   return sum(f,a + dx / 2,add_dx,b) * dx;\n}\n          \nfunction cube(x) {\n   return x * x * x;\n}\n          \nintegral(cube,0,1,0.001);','javascript_272','',event,1.0);">integral(cube,0,1,0.001);</pre>

        (The exact value of the integral of <span class="schemeinline">cube</span> 
        between 0 and 1 is 1/4.)
        </div>

        <div class="exercise">
<b>Exercise 1.30.</b><a name="ex:simpsons-rule"></a> 
          
          Simpson&#146;s Rule is a more accurate method of numerical integration than
          the method illustrated above.  Using Simpson&#146;s Rule, the integral of a
          function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_460.png"></span> between <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_461.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_462.png"></span> is approximated as
          <P><img src="img_javascript/latex_28.png"></P>
          where <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_463.png"></span>, for some even integer <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_464.png"></span>, and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_465.png"></span>.
          (Increasing <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_466.png"></span> increases the accuracy of the approximation.)  Define
          a
          function
          that takes as arguments <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_467.png"></span>, <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_468.png"></span>, <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_469.png"></span>, and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_470.png"></span> and returns
          the value of the integral, computed using Simpson&#146;s Rule.
          Use your
          function
          to integrate <span class="schemeinline">cube</span> between 0 and 1
          (with <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_471.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_472.png"></span>), and compare the results to those of the
          <span class="schemeinline">integral</span>
          function
          shown above.
      <div style="position:absolute;display:none;" id="javascript_273_div"></div>
      
        </div>
        

        <div class="exercise">
<b>Exercise 1.31.</b> 
          
          The <span class="schemeinline">sum</span>
          function
          above generates a linear recursion.  The
          function
          can be rewritten so that the sum is performed iteratively.
          Show how to do this by filling in the missing expressions in the
          following definition:
          <form name="form_275" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_275.png"></form>
 <div style="position:absolute;display:none;" id="javascript_276_div"></div>
        </div>

        <div class="exercise">
<b>Exercise 1.32.</b> 
          
          <ol class="exercise">
            <li>The <span class="schemeinline">sum</span>
              function
              is only the simplest of a vast number of
              similar abstractions that can be captured as higher-order
              functions.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_3"><a class="link" href="#footnote_3">3</a></a></span>  
              Write an analogous
              function
              called <span class="schemeinline">product</span> that returns the product of the values of a
              function at points over a given range.
              Show how to define 
              
              <span class="schemeinline">factorial</span> in terms of
              <span class="schemeinline">product</span>.  Also use <span class="schemeinline">product</span> to compute approximations to
              
              <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_474.png"></span> using the 
              formula<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_4"><a class="link" href="#footnote_4">4</a></a></span>
              <P><img src="img_javascript/latex_29.png"></P>
            </li>
            <li>
              If your <span class="schemeinline">product</span>
              function
              generates a recursive process, write one that generates
              an iterative process.
              If it generates an iterative process, write one that generates
              a recursive process.
            </li>
          </ol>
          <a name="ex:product"></a>
      <div style="position:absolute;display:none;" id="javascript_277_div"></div>
      
        </div>

        <div class="exercise">
<b>Exercise 1.33.</b>
          
          
          
          <ol class="exercise">
            <li>
              Show that <span class="schemeinline">sum</span> and <span class="schemeinline">product</span>
              (exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#ex:product">1.32</a>) are both special cases of a still more
              general notion called <span class="schemeinline">accumulate</span> that combines a 
              collection of
              terms, using some general accumulation function:
              <form name="form_279" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_279.png"></form>
              The function <span class="javascriptinline">accumulate</span>
              takes as arguments the same term and range
              specifications as <span class="schemeinline">sum</span> and <span class="schemeinline">product</span>, together with a <span class="schemeinline">combiner</span>
              function
              (of two arguments) that specifies how the current
              term is to be combined with the accumulation of the preceding terms
              and a 
              <span class="javascriptinline">null_value</span>
              that specifies what base value to use
              when the terms run out.  Write <span class="schemeinline">accumulate</span>
              and show how <span class="schemeinline">sum</span> and <span class="schemeinline">product</span> can both
              be defined as simple calls to <span class="schemeinline">accumulate</span>.
            </li>
            <li>
              If your <span class="schemeinline">accumulate</span>
              function
              generates a recursive process, write one that generates
              an iterative process.
              If it generates an iterative process, write one that generates
              a recursive process.
            </li>
          </ol>
          <a name="ex:accumulate"></a>
        </div>

        <div class="exercise">
<b>Exercise 1.34.</b> 
          
          You can obtain an even more general version of <span class="schemeinline">accumulate</span>
          (exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#ex:accumulate">1.33</a>) by introducing the notion of a 
          
          <em>
            filter</em> on the terms to be combined.  That is, combine only those
          terms derived from values in the range that satisfy a specified
          condition.  The resulting 
          <span class="javascriptinline">filtered_accumulate</span>
          abstraction takes the same arguments as accumulate, together with an additional
          predicate of one argument that specifies the filter.  
          Write <span class="javascriptinline">filtered_accumulate</span> as a
          function.  
          Show how to express the
          following using <span class="javascriptinline">filtered_accumulate</span>:

          <ol class="exercise">
            <li>
              the sum of the squares of the prime numbers in the interval 
              <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_475.png"></span> to
              <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_476.png"></span> 
              (assuming that you have a 
              <span class="javascriptinline">is_prime</span> 
              predicate already written)
            </li>
            <li>
              the product of all the positive integers less than <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_477.png"></span>
              
              that are relatively prime to&nbsp;<span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_478.png"></span> 
              (i.e., all positive integers
              <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_479.png"></span> such that 
              <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_480.png"></span>).
            </li>
          </ol>
          <a name="ex:filtered-accumulate"></a>
        </div>
        
        
      

      <h3><a name="subsection_1_3_2">1.3.2&nbsp;
          Function Definition Expressions
          </a></h3>
        

        <a name="sec:lambda"></a>
        <a name="sec:introduce-let"></a>

        
        <div class="normaltext">
          In using <span class="javascriptinline">sum</span> as in section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#sec:procedures-as-parameters">1.3.1</a>,
          it seems terribly awkward to have to define trivial
          functions
          such as
          <span class="javascriptinline">pi_term</span> and <span class="javascriptinline">pi_next</span> just 
          so we can use them as arguments to our higher-order
          function.
          Rather than define <span class="javascriptinline">pi_next</span> and 
          <span class="javascriptinline">pi_term</span>, it would be more convenient
          to have a way to directly specify &#147;the
            function that returns its
            input incremented by 4&#148; and &#147;the
            function that returns the
            reciprocal of its input times its input plus 2.&#148;  We can do this by
          introducing <em>function definition expressions</em> that look just like
          function definition statements, but leave out the name of the function.
          Using this new kind of expression, we can describe what we want as

          <form name="form_282" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_282.png"></form>

          and 

          <form name="form_283" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_283.png"></form>
        </div>
          

        <div class="normaltext">
          Then our 
          <span class="javascriptinline">pi_sum</span>
          function
          can be expressed without defining any auxiliary
          functions
          as

        <div style="position:absolute;display:none;" id="javascript_284_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction sum(term,a,next,b) {\n   if (a &gt; b)\n        return 0;\n   else return term(a) + \n               sum(term,next(a),next,b);\n}\n          \nfunction pi_sum(a,b) {\n   return sum(function(x) { return 1.0 / (x * (x + 2)); },\n              a,\n              function(x) { return x + 4; },\n              b);\n}\n\n// example\n\n8 * pi_sum(1,1000);','javascript_284','',event,1.0);">function pi_sum(a,b) {
   return sum(function(x) { return 1.0 / (x * (x + 2)); },
              a,
              function(x) { return x + 4; },
              b);
}</pre>
        
        </div>

        <div class="normaltext">
          Again using 
          a function definition expression, 
          we can write the <span class="schemeinline">integral</span>
          function
          without having to define the auxiliary
          function
          <span class="javascriptinline">add_dx</span>:
        <div style="position:absolute;display:none;" id="javascript_285_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction sum(term,a,next,b) {\n   if (a &gt; b)\n        return 0;\n   else return term(a) + \n               sum(term,next(a),next,b);\n}\n          \nfunction cube(x) {\n   return x * x * x;\n}\n          \nfunction integral(f,a,b,dx) {\n   return sum(f,\n              a + dx / 2.0,\n              function(x) { return x + dx; },\n              b)\n          *\n          dx;\n}\n\n// example\n\nintegral(cube,0,1,0.01);','javascript_285','',event,1.0);">function integral(f,a,b,dx) {
   return sum(f,
              a + dx / 2.0,
              function(x) { return x + dx; },
              b)
          *
          dx;
}</pre>
        </div>
        
        
            <span style="color:black" title=""></span>
          
        <div class="normaltext">
          The resulting
          function
          is just as much a
          function
          as one that is
          created using 
          a function definition statement.  
          The only difference is that it has not
          been associated with any name in the environment.  In fact,
          
        <div style="position:absolute;display:none;" id="javascript_287_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction plus4(x) { return x + 4; }\n\n// example\n\nplus4(3);','javascript_287','',event,1.0);">function plus4(x) { return x + 4; }</pre>

        

          is equivalent to
          
        <div style="position:absolute;display:none;" id="javascript_289_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar plus4 = function(x) { return x + 4; }\n\n// example\n\nplus4(3);','javascript_289','',event,1.0);">var plus4 = function(x) { return x + 4; }</pre>
        </div>
        <div class="normaltext">
          We can read a 
          function definition
          expression as follows:
          <form name="form_290" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_290.png"></form>
        </div>

        <div class="normaltext">
          
          
          
          Like any expression that has a
          function
          as its value, a
          function definition
          expression can be used as the function expression in an application
          combination such as
        <div style="position:absolute;display:none;" id="javascript_291_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction square(x) { return x * x; }\n                \n(function(x,y,z) { \n    return x + y + square(z); \n})(1,2,3);','javascript_291','',event,1.0);">(function(x,y,z) { 
    return x + y + square(z); 
})(1,2,3);</pre>
        or, more generally, in any context where we would normally use a
        function
        name.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_6"><a class="link" href="#footnote_6">6</a></a></span> Note that the JavaScript parser requires parentheses 
            around the function in this case.
        </div>

        <H4>Using 
            <span class="javascriptinline">var</span>
            to create local variables
          </H4>
          
        
        
        

        <div class="normaltext">
          Another use of 
          function definition expressions
          is in creating local variables.
          We often need local variables in our
          functions
          other than those that have
          been bound as formal parameters.  For example, suppose we wish to
          compute the function
          <P><img src="img_javascript/latex_30.png"></P>
          which we could also express as
          <P><img src="img_javascript/latex_31.png"></P>
          In writing a
          function
          to compute <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_489.png"></span>, we would like to include as
          local variables not only <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_490.png"></span> and 
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_491.png"></span>  but also the names of
          intermediate quantities like <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_492.png"></span> and 
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_493.png"></span>.  One way to
          accomplish this is to use an auxiliary
          function
          to bind the local variables:
        <div style="position:absolute;display:none;" id="javascript_292_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction square(x) { return x * x; }\n                \nfunction f(x,y) {\n   function f_helper(a,b) {\n      return x * square(a) + \n             y * b + \n             a * b;\n   }\n   return f_helper(1 + x * y,\n                   1 - y);\n}\n\n// example\n\nf(3,4);','javascript_292','',event,1.0);">function f(x,y) {
   function f_helper(a,b) {
      return x * square(a) + 
             y * b + 
             a * b;
   }
   return f_helper(1 + x * y,
                   1 - y);
}</pre>

        
        </div>

        <div class="normaltext">
          Of course, we could use a 
          function definition
          expression to specify an anonymous
          function
          for binding our local variables.  The body of
          <span class="schemeinline">f</span> then becomes a single call to that
          function:

        <div style="position:absolute;display:none;" id="javascript_294_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction square(x) { return x * x; }\n                \nfunction f(x,y) {\n   return function(a,b) {\n             return x * square(a) + \n                    y * b + \n                    a * b;\n          }(1 + x * y, 1 - y);\n}\n\n// example\n\nf(3,4);','javascript_294','',event,1.0);">function f(x,y) {
   return function(a,b) {
             return x * square(a) + 
                    y * b + 
                    a * b;
          }(1 + x * y, 1 - y);
}</pre>
        </div>

        
            <div class="normaltext">
              A more convenient way to define local variables is by using
              <span class="javascriptinline">var</span> within the body of
              the function. Variables declared this way have the entire
              function body as their scope.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_7"><a class="link" href="#footnote_7">7</a></a></span>
              Using <span class="javascriptinline">var</span>, the 
              <span class="javascriptinline">f</span> function can be written as
        <div style="position:absolute;display:none;" id="javascript_296_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction square(x) { return x * x; }\n                \nfunction f(x,y) {\n   var a = 1 + x * y;\n   var b = 1 - y;\n   return x * square(a) + \n          y * b + \n          a * b;\n}\n\n// example\n\nf(3,4);','javascript_296','',event,1.0);">function f(x,y) {
   var a = 1 + x * y;
   var b = 1 - y;
   return x * square(a) + 
          y * b + 
          a * b;
}</pre>
          </div>
          

        
            <span style="color:black" title=""></span>
          

        <div class="exercise">
<b>Exercise 1.35.</b> 
          Suppose we define the
          function

        <div style="position:absolute;display:none;" id="javascript_304_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction f(g) {\n   return g(2);\n}','javascript_304','',event,1.0);">function f(g) {
   return g(2);
}</pre>

          Then we have

        <div style="position:absolute;display:none;" id="javascript_305_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction f(g) {\n   return g(2);\n}\n          \nfunction square(x) { return x * x; }\n                \nf(square);','javascript_305','',event,1.0);">f(square);</pre>

        <div style="position:absolute;display:none;" id="javascript_306_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction f(g) {\n   return g(2);\n}\n          \nf(function(z) { return z * (z + 1); });','javascript_306','',event,1.0);">f(function(z) { return z * (z + 1); });</pre>
          What happens if we (perversely) ask the interpreter to evaluate the
          combination 
        <span class="javascriptinline">f(f)</span>?  
        Explain.
    <div style="position:absolute;display:none;" id="javascript_307_div"></div>
        </div>
      

      <h3><a name="subsection_1_3_3">1.3.3&nbsp;
            Functions
            as General Methods
          </a></h3> 
          

          <a name="sec:proc-general-methods"></a>
          
          

          <div class="normaltext">
          We introduced compound
          functions
          in
          section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_1.html')" href="#sec:compound-procedures">1.1.4</a> as a mechanism for abstracting
          patterns of numerical operations so as to make them independent of the
          particular numbers involved.  With higher-order
          functions, such as
          the <span class="schemeinline">integral</span>
          function
          of
          section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#sec:procedures-as-parameters">1.3.1</a>, we began to see a more
          powerful kind of abstraction:
          functions
          used to express general
          methods of computation, independent of the particular functions
          involved.  In this section we discuss two more elaborate
          examples—general methods for finding zeros and fixed points of
          functions—and show how these methods can be expressed directly as
          functions.
          </div>

          <H4>Finding roots of equations by the half-interval method</H4>
            
          

          <div class="normaltext">
          
          The <em>half-interval method</em> is a simple but powerful technique for
          finding roots of an equation <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_494.png"></span>, 
          where <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_495.png"></span> is a continuous
          function.  The idea is that, if we are given points <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_496.png"></span> and 
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_497.png"></span> such that <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_498.png"></span>, 
          then <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_499.png"></span> must have at least one zero between
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_500.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_501.png"></span>.  
          To locate a zero, let <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_502.png"></span> be the average of 
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_503.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_504.png"></span>
          and compute <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_505.png"></span>.  If <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_506.png"></span>, 
          then <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_507.png"></span> must have a zero between
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_508.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_509.png"></span>.  
          If <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_510.png"></span>, then <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_511.png"></span> must 
          have a zero between <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_512.png"></span> and
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_513.png"></span>.  Continuing in this way, we can identify smaller and smaller
          intervals on which <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_514.png"></span> must have a zero.  When we reach a point where
          the interval is small enough, the process stops.  Since the interval
          of uncertainty is reduced by half at each step of the process, the
          number of steps required grows as <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_515.png"></span>, 
          where <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_516.png"></span> is the
          length of the original interval and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_517.png"></span> is the error tolerance
          (that is, the size of the interval we will consider &#147;small enough&#148;).
          Here is a
          function
          that implements this strategy:

        

        <div style="position:absolute;display:none;" id="javascript_309_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction average(x,y) {\n   return (x + y) / 2;\n}\n              \nfunction positive(x) { return x &gt; 0; }\nfunction negative(x) { return x &lt; 0; }\n          \nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nfunction close_enough(x,y) {\n   return abs(x - y) &lt; 0.001;\n}\n          \nfunction search(f,neg_point,pos_point) {\n   var midpoint = average(neg_point,pos_point);\n   if (close_enough(neg_point,pos_point))\n        return midpoint;\n   else {\n      var test_value = f(midpoint);\n      if (positive(test_value))\n           return search(f,neg_point,midpoint);\n      else if (negative(test_value))\n           return search(f,midpoint,pos_point);\n      else return midpoint;\n   }\n}','javascript_309','',event,1.0);">function search(f,neg_point,pos_point) {
   var midpoint = average(neg_point,pos_point);
   if (close_enough(neg_point,pos_point))
        return midpoint;
   else {
      var test_value = f(midpoint);
      if (positive(test_value))
           return search(f,neg_point,midpoint);
      else if (negative(test_value))
           return search(f,midpoint,pos_point);
      else return midpoint;
   }
}</pre>
          </div>

          <div class="normaltext">
          We assume that we are initially given the function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_518.png"></span> together with
          points at which its values are negative and positive.  We first
          compute the midpoint of the two given points.  Next we check to see if
          the given interval is small enough, and if so we simply return the
          midpoint as our answer.  Otherwise, we compute as a test value the
          value of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_519.png"></span> at the midpoint.  If the test value is positive, then
          we continue the process with a new interval running from the original
          negative point to the midpoint.  If the test value is negative, we
          continue with the interval from the midpoint to the positive point.
          Finally, there is the possibility that the test value is&nbsp;0, in which
          case the midpoint is itself the root we are searching for.

          To test whether the endpoints are &#147;close enough&#148; we can use a
          function
          similar to the one used in section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_1.html')" href="#sec:sqrt">1.1.7</a> for
          computing square roots:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_9"><a class="link" href="#footnote_9">9</a></a></span>

          <div style="position:absolute;display:none;" id="javascript_310_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nfunction close_enough(x,y) {\n   return abs(x - y) &lt; 0.001;\n}\n\n// example\n\nclose_enough(7.7654,7.7666);','javascript_310','',event,1.0);">function close_enough(x,y) {
   return abs(x - y) &lt; 0.001;
}</pre>

          
          </div>

          <div class="normaltext">
          <span class="schemeinline">Search</span> is awkward to use directly, because
          we can accidentally give it points at which <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_520.png"></span>&#146;s
          values do not have the required sign, in which case we get a wrong answer.
          Instead we will use <span class="schemeinline">search</span> via the following
          function, which
          checks to see which of the endpoints has a negative function value and
          which has a positive value, and calls the <span class="schemeinline">search</span>
          function
          accordingly.  If the function has the same sign on the two given
          points, the half-interval method cannot be used, in which case the
          function
          signals an error.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_10"><a class="link" href="#footnote_10">10</a></a></span>

          <div style="position:absolute;display:none;" id="javascript_312_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction average(x,y) {\n   return (x + y) / 2;\n}\n              \nfunction positive(x) { return x &gt; 0; }\nfunction negative(x) { return x &lt; 0; }\n          \nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nfunction close_enough(x,y) {\n   return abs(x - y) &lt; 0.001;\n}\n          \nfunction search(f,neg_point,pos_point) {\n   var midpoint = average(neg_point,pos_point);\n   if (close_enough(neg_point,pos_point))\n        return midpoint;\n   else {\n      var test_value = f(midpoint);\n      if (positive(test_value))\n           return search(f,neg_point,midpoint);\n      else if (negative(test_value))\n           return search(f,midpoint,pos_point);\n      else return midpoint;\n   }\n}\n          \nfunction half_interval_method(f,a,b) {\n   var a_value = f(a);\n   var b_value = f(b);\n   if (negative(a_value) &amp;&amp; positive(b_value))\n        return search(f,a,b);\n   else if (negative(b_value) &amp;&amp; positive(a_value))\n        return search(f,b,a);\n   else error(&quot;values are not of opposite sign: &quot;+a+&quot;, &quot;+b);\n}\n\n// example\n\nhalf_interval_method(Math.sin, 2.0, 4.0);','javascript_312','',event,1.0);">function half_interval_method(f,a,b) {
   var a_value = f(a);
   var b_value = f(b);
   if (negative(a_value) &amp;&amp; positive(b_value))
        return search(f,a,b);
   else if (negative(b_value) &amp;&amp; positive(a_value))
        return search(f,b,a);
   else error("values are not of opposite sign: "+a+", "+b);
}</pre>
          

          
          The following example uses the half-interval method to approximate <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_522.png"></span>
          as the root between 2 and 4 of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_523.png"></span>:

          <div style="position:absolute;display:none;" id="javascript_313_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction average(x,y) {\n   return (x + y) / 2;\n}\n              \nfunction positive(x) { return x &gt; 0; }\nfunction negative(x) { return x &lt; 0; }\n          \nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nfunction close_enough(x,y) {\n   return abs(x - y) &lt; 0.001;\n}\n          \nfunction search(f,neg_point,pos_point) {\n   var midpoint = average(neg_point,pos_point);\n   if (close_enough(neg_point,pos_point))\n        return midpoint;\n   else {\n      var test_value = f(midpoint);\n      if (positive(test_value))\n           return search(f,neg_point,midpoint);\n      else if (negative(test_value))\n           return search(f,midpoint,pos_point);\n      else return midpoint;\n   }\n}\n          \nfunction half_interval_method(f,a,b) {\n   var a_value = f(a);\n   var b_value = f(b);\n   if (negative(a_value) &amp;&amp; positive(b_value))\n        return search(f,a,b);\n   else if (negative(b_value) &amp;&amp; positive(a_value))\n        return search(f,b,a);\n   else error(&quot;values are not of opposite sign: &quot;+a+&quot;, &quot;+b);\n}\n          \nhalf_interval_method(Math.sin, 2.0, 4.0);','javascript_313','',event,1.0);">half_interval_method(Math.sin, 2.0, 4.0);</pre>

          Here is another example, using the half-interval method
          to search for a root of the equation <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_524.png"></span>
          between 1 and 2:

          <div style="position:absolute;display:none;" id="javascript_314_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction average(x,y) {\n   return (x + y) / 2;\n}\n              \nfunction positive(x) { return x &gt; 0; }\nfunction negative(x) { return x &lt; 0; }\n          \nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nfunction close_enough(x,y) {\n   return abs(x - y) &lt; 0.001;\n}\n          \nfunction search(f,neg_point,pos_point) {\n   var midpoint = average(neg_point,pos_point);\n   if (close_enough(neg_point,pos_point))\n        return midpoint;\n   else {\n      var test_value = f(midpoint);\n      if (positive(test_value))\n           return search(f,neg_point,midpoint);\n      else if (negative(test_value))\n           return search(f,midpoint,pos_point);\n      else return midpoint;\n   }\n}\n          \nfunction half_interval_method(f,a,b) {\n   var a_value = f(a);\n   var b_value = f(b);\n   if (negative(a_value) &amp;&amp; positive(b_value))\n        return search(f,a,b);\n   else if (negative(b_value) &amp;&amp; positive(a_value))\n        return search(f,b,a);\n   else error(&quot;values are not of opposite sign: &quot;+a+&quot;, &quot;+b);\n}\n          \nhalf_interval_method(\n  function(x) { return x * x * x - 2 * x - 3; },\n  1.0,\n  2.0);','javascript_314','',event,1.0);">half_interval_method(
  function(x) { return x * x * x - 2 * x - 3; },
  1.0,
  2.0);</pre>
          
          </div>

          <H4>Finding fixed points of functions</H4>
            
          

          <div class="normaltext">
          
          
          A number <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_525.png"></span> is called a <em>fixed point</em> of a 
          function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_526.png"></span> if <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_527.png"></span>
          satisfies the equation <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_528.png"></span>.  
          For some functions <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_529.png"></span> we can locate
          a fixed point by beginning with an initial guess and applying <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_530.png"></span>
          repeatedly,
          <P><img src="img_javascript/latex_33.png"></P>
          until the value does not change very much.  Using this idea, we can
          devise a
          function
          <span class="javascriptinline">fixed_point</span> that takes as inputs a function
          and an initial guess and produces an approximation to a fixed point of
          the function.  We apply the function repeatedly until we find two
          successive values whose difference is less than some prescribed
          tolerance:

          <div style="position:absolute;display:none;" id="javascript_315_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n\n// example\n\nfixed_point(Math.cos,1.0);','javascript_315','',event,1.0);">var tolerance = 0.00001;

function fixed_point(f,first_guess) {
   function close_enough(x,y) {
      return abs(x - y) &lt; tolerance;
   }
   function try_with(guess) {
      var next = f(guess);
      if (close_enough(guess,next))
           return next;
      else return try_with(next);
   }
   return try_with(first_guess);
}</pre>
          </div>

          <div class="normaltext">
          
          
          For example, we can use this method to approximate the fixed point of
          the cosine function, starting with 1 as an initial 
          approximation:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_11"><a class="link" href="#footnote_11">11</a></a></span>
          
          <div style="position:absolute;display:none;" id="javascript_316_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfixed_point(Math.cos,1.0);','javascript_316','',event,1.0);">fixed_point(Math.cos,1.0);</pre>
          </div>

          <div class="normaltext">
          Similarly, we can find a solution to the equation
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_532.png"></span>:
          
          <div style="position:absolute;display:none;" id="javascript_317_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfixed_point(\n  function(y) { return Math.sin(y) + Math.cos(y); },\n  1.0);','javascript_317','',event,1.0);">fixed_point(
  function(y) { return Math.sin(y) + Math.cos(y); },
  1.0);</pre>
          </div>

          <div class="normaltext">
          The fixed-point process is reminiscent of the process we used for
          finding square roots in section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_1.html')" href="#sec:sqrt">1.1.7</a>.  Both are based on the
          idea of repeatedly improving a guess until the result satisfies some
          criterion.  In fact, we can readily formulate the 
          
          square-root
          computation as a fixed-point search.  Computing the square root of
          some number <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_533.png"></span> requires finding a 
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_534.png"></span> such that <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_535.png"></span>.  Putting
          this equation into the equivalent form <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_536.png"></span>, we recognize that we
          are looking for a fixed point of the function<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_12"><a class="link" href="#footnote_12">12</a></a></span> 
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_543.png"></span>, and we
          can therefore try to compute square roots as

          <div style="position:absolute;display:none;" id="javascript_318_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfunction sqrt(x) {\n   return fixed_point(\n            function(y) { return x / y; },\n            1.0);\n}\n\n// warning: does not converge!\n\n// example\n\nsqrt(5);','javascript_318','',event,1.0);">function sqrt(x) {
   return fixed_point(
            function(y) { return x / y; },
            1.0);
}

// warning: does not converge!</pre>

          Unfortunately, this fixed-point search does not converge.  Consider an
          initial guess <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_544.png"></span>.  The next guess is <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_545.png"></span> and the next
          guess is <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_546.png"></span>.  This results in an infinite
          loop in which the two guesses <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_547.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_548.png"></span> repeat over and over,
          oscillating about the answer.
          </div>

          <div class="normaltext">
          One way to control such oscillations is to prevent the guesses from
          changing so much.
          Since the answer is always between our guess <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_549.png"></span>
          and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_550.png"></span>, we can make a new guess that is not 
          as far from <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_551.png"></span> as <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_552.png"></span>
          by averaging <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_553.png"></span> with <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_554.png"></span>, 
          so that the next guess after
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_555.png"></span> is <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_556.png"></span> 
          instead of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_557.png"></span>.
          The process of making such a sequence of guesses is simply the process
          of looking for a fixed point of 
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_558.png"></span>:

          <div style="position:absolute;display:none;" id="javascript_319_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfunction average(x,y) {\n   return (x + y) / 2;\n}\n              \nfunction sqrt(x) {\n   return fixed_point(\n            function(y) { return average(y,x / y); },\n            1.0);\n}\n\n// example\n\nsqrt(5);','javascript_319','',event,1.0);">function sqrt(x) {
   return fixed_point(
            function(y) { return average(y,x / y); },
            1.0);
}</pre>

          (Note that <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_559.png"></span> is a simple transformation of the
          equation <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_560.png"></span>; to derive it, add <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_561.png"></span> to both sides of the equation
          and divide by&nbsp;2.)
          </div>

          <div class="normaltext">
          With this modification, the square-root
          function
          works.  In fact, if
          we unravel the definitions, we can see that the sequence of
          approximations to the square root generated here is precisely the
          same as the one generated by our original square-root
          function
          of
          section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_1.html')" href="#sec:sqrt">1.1.7</a>.  This approach of averaging
          successive approximations to a solution, a technique we call
          
          <em>average damping</em>, often aids the convergence of fixed-point
          searches.
          
          
          </div>

          <div class="exercise">
<b>Exercise 1.36.</b>
            
            
            Show that the golden ratio <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_562.png"></span> 
            (section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_2.html')" href="#sec:tree-recursion">1.2.2</a>)
            is a fixed point of the transformation <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_563.png"></span>, 
            and use this fact to compute <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_564.png"></span> by 
            means of the 
            <span class="javascriptinline">fixed_point</span>
            function.
      <div style="position:absolute;display:none;" id="javascript_320_div"></div>
      
          </div>

          <div class="exercise">
<b>Exercise 1.37.</b>
            Modify <span class="javascriptinline">fixed_point</span> so that it prints the sequence of
            approximations it generates, using
            the <span class="schemeinline">newline</span> and <span class="schemeinline">display</span> 
            primitives shown in exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_1_2.html')" href="#ex:search-for-primes">1.23</a>.  
            Then find a solution to <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_565.png"></span> by finding a fixed 
            point of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_566.png"></span>.  (Use Scheme&#146;s 

            primitive <span class="schemeinline">log</span>
            function, 
            which computes natural logarithms.)  Compare the number of steps this takes with and without
            average damping.  (Note that you cannot start 
            <span class="javascriptinline">fixed_point</span> with a
            guess of 1, as this would cause division by <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_567.png"></span>.)
            <a name="ex:log-fixed-point"></a>
          </div>

          <div class="exercise">
<b>Exercise 1.38.</b>
            
            <ul>
              <li>
                An infinite <em>continued fraction</em> is an expression of the form
                <P><img src="img_javascript/latex_34.png"></P>
                
                
                As an example, one can show that the infinite continued fraction
                expansion with the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_568.png"></span> and the 
                <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_569.png"></span> all equal to 1 produces
                <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_570.png"></span>, where <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_571.png"></span> 
                is the golden ratio (described in section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_2.html')" href="#sec:tree-recursion">1.2.2</a>).
                One way to approximate an
                infinite continued fraction is to truncate the expansion after a given
                number of terms.  Such a truncation—a so-called 
                <em><span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_572.png"></span>-term finite
                  continued fraction</em>—has the form
                <P><img src="img_javascript/latex_35.png"></P>
                Suppose that <span class="schemeinline">n</span> and <span class="schemeinline">d</span> are
                functions
                of one argument (the
                term index <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_573.png"></span>) that return the 
                <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_574.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_575.png"></span> 
                of the terms of the continued fraction.  Define a
                function
                <span class="javascriptinline">cont_frac</span>
                such that evaluating
                <span class="javascriptinline">cont_frac(n,d,k)</span>
                computes the value of the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_576.png"></span>-term finite
                continued fraction.  Check your
                function
                by approximating <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_577.png"></span> using
                

                <div style="position:absolute;display:none;" id="javascript_323_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// cont_frac to be written by student; see Exercise 1.37\n                  \ncont_frac(function(i) { return 1.0; },\n          function(i) { return 1.0; },\n          k);','javascript_323','',event,1.0);">cont_frac(function(i) { return 1.0; },
          function(i) { return 1.0; },
          k);</pre>
                for successive values of <span class="schemeinline">k</span>.  
                How large must you make <span class="schemeinline">k</span>
                in order to get an approximation that is accurate to 4 decimal places?
              </li>
              <li>
                If your <span class="javascriptinline">cont_frac</span>
                function
                generates a recursive process, write one that generates
                an iterative process.
                If it generates an iterative process, write one that generates
                a recursive process.
              </li>
            </ul>
            <a name="ex:continued-fractions"></a>

        <div style="position:absolute;display:none;" id="javascript_324_div"></div>
        
          </div>

          <div class="exercise">
<b>Exercise 1.39.</b>
            
            In 1737, the Swiss mathematician Leonhard Euler published a memoir
            <em>De Fractionibus Continuis</em>, which included a 
            
            
            continued fraction
            expansion for <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_580.png"></span>, 
            where <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_581.png"></span> is the base of the natural logarithms.
            In this fraction, the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_582.png"></span> are all 1, 
            and the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_583.png"></span> are successively
            1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, &#8230;.  Write a program that uses
            your <span class="schemeinline">cont-frac</span>
            function
            from
            exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#ex:continued-fractions">1.38</a> to approximate <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_584.png"></span>, based on
            Euler&#146;s expansion.
          </div>

          <div class="exercise">
<b>Exercise 1.40.</b>
            
            
            
            A continued fraction representation of the tangent function was
            published in 1770 by the German mathematician J.H. Lambert:
            <P><img src="img_javascript/latex_36.png"></P>
            where <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_585.png"></span> is in radians.
            Define a
            function
            <span class="schemeinline">(tan-cf x k)</span> that computes an approximation
            to the tangent function based on Lambert&#146;s
            formula.  <span class="schemeinline">K</span> specifies the number of terms to compute, as in
            exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#ex:continued-fractions">1.38</a>.
          </div>
      
      <h3><a name="subsection_1_3_4">1.3.4&nbsp;
              Functions
              as Returned Values
            </a></h3> 
            

          <a name="sec:proc-returned-values"></a>
          
          

          <div class="normaltext">
          The above examples demonstrate how
          the ability to pass
          functions
          as arguments significantly enhances
          the expressive power of our programming language.  We can achieve even
          more expressive power by creating
          functions
          whose returned values are
          themselves
          functions.
          </div>

          <div class="normaltext">
          We can illustrate this idea by looking again at the fixed-point
          example described at the end of
          section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#sec:proc-general-methods">1.3.3</a>.  We formulated a new version
          of the square-root
          function
          as a fixed-point search, starting with
          the observation that <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_586.png"></span> is a fixed-point of the function
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_587.png"></span>.  Then we used average damping to make the
          approximations converge.  Average damping is a useful general
          technique in itself.  Namely, given a function&nbsp;<span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_588.png"></span>, we consider the
          function whose value at <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_589.png"></span> is equal to the average of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_590.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_591.png"></span>.
          </div>
          
          <div class="normaltext">
          We can express the idea of average damping by means of the
          following
          function:
          <div style="position:absolute;display:none;" id="javascript_326_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction average(x,y) {\n   return (x + y) / 2;\n}\n              \nfunction average_damp(f) {\n   return function(x) { \n             return average(x,f(x)); \n          }\n}\n\n// example\n\naverage_damp(square)(10);','javascript_326','',event,1.0);">function average_damp(f) {
   return function(x) { 
             return average(x,f(x)); 
          }
}</pre>
          </div>

          <div class="normaltext">
          
              The function
              <span class="javascriptinline">average_damp</span>
            
          is a
          function
          that takes as its argument a
          function
          <span class="schemeinline">f</span> and returns as its value a
          function
          (produced by the 
          function definition expression) that, when applied to a number <span class="schemeinline">x</span>, produces the
          average of <span class="schemeinline">x</span> and 
          <span class="javascriptinline">f(x)</span>.  
          For example, applying 
          
              <span class="javascriptinline">average_damp</span>
            
          to the <span class="schemeinline">square</span>
          function
          produces a
          function
          whose
          value at some number <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_592.png"></span> is the average of 
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_593.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_594.png"></span>.  
          Applying this resulting
          function
          to 10 returns the average of 10 and 100, or
          55:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_13"><a class="link" href="#footnote_13">13</a></a></span>
          <div style="position:absolute;display:none;" id="javascript_327_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction average(x,y) {\n   return (x + y) / 2;\n}\n              \nfunction average_damp(f) {\n   return function(x) { \n             return average(x,f(x)); \n          }\n}\n          \nfunction square(x) { return x * x; }\n                \naverage_damp(square)(10);','javascript_327','',event,1.0);">average_damp(square)(10);</pre>
          </div>

          <div class="normaltext">
          
          Using 
          <span class="javascriptinline">average_damp</span>,
          we can reformulate the square-root
          function
          as follows:

          <div style="position:absolute;display:none;" id="javascript_328_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction average(x,y) {\n   return (x + y) / 2;\n}\n              \nfunction average_damp(f) {\n   return function(x) { \n             return average(x,f(x)); \n          }\n}\n          \nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfunction sqrt(x) {\n   return fixed_point(\n            average_damp(\n              function(y) { return x / y; }),\n            1.0);\n}\n\n// example\n\nsqrt(5);','javascript_328','',event,1.0);">function sqrt(x) {
   return fixed_point(
            average_damp(
              function(y) { return x / y; }),
            1.0);
}</pre>
          </div>

          <div class="normaltext">
          Notice how this formulation makes explicit the three ideas in the
          method: fixed-point search, average damping, and the function
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_595.png"></span>.  It is instructive to compare this formulation of the
          square-root method with the original version given in
          section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_1.html')" href="#sec:sqrt">1.1.7</a>.  Bear in mind that these
          functions
          express
          the same process, and notice how much clearer the idea becomes when we
          express the process in terms of these abstractions.  In general, there
          are many ways to formulate a process as a
          function.  Experienced
          programmers know how to choose process formulations that are
          particularly perspicuous, and where useful elements of the process are
          exposed as separate entities that can be reused in other applications.
          As a simple example of reuse, notice that the cube root of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_596.png"></span> is a
          fixed point of the function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_597.png"></span>, so we can immediately
          generalize our square-root
          function
          to one that extracts 
          
          
          cube
          roots:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_14"><a class="link" href="#footnote_14">14</a></a></span>

          <div style="position:absolute;display:none;" id="javascript_329_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction average(x,y) {\n   return (x + y) / 2;\n}\n              \nfunction average_damp(f) {\n   return function(x) { \n             return average(x,f(x)); \n          }\n}\n          \nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfunction square(x) { return x * x; }\n                \nfunction cube_root(x) {\n   return fixed_point(\n            average_damp(\n              function(y) { return x / square(y); }),\n            1.0);\n}\n\n// example\n\ncube_root(27);','javascript_329','',event,1.0);">function cube_root(x) {
   return fixed_point(
            average_damp(
              function(y) { return x / square(y); }),
            1.0);
}</pre>

          

          
          </div>

          <H4>Newton&#146;s method</H4>
            
          

          <div class="normaltext">
          
          When we first introduced the square-root
          function, in
          section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_1.html')" href="#sec:sqrt">1.1.7</a>, we mentioned that this was a special case of
          <em>Newton&#146;s method</em>.  
          If <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_598.png"></span> is a differentiable function, then a solution of
          the equation <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_599.png"></span> is a fixed point of the function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_600.png"></span>
          where
          <P><img src="img_javascript/latex_37.png"></P>
          and
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_601.png"></span> is the derivative of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_602.png"></span> evaluated at <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_603.png"></span>.  
          
          Newton&#146;s
          method is the use of the fixed-point method we saw above to
          approximate a solution of the equation by finding a fixed point of
          the function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_604.png"></span>.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_15"><a class="link" href="#footnote_15">15</a></a></span>
          For many functions <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_606.png"></span> and for sufficiently good initial guesses for
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_607.png"></span>, Newton&#146;s method converges very rapidly to a solution of
          <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_608.png"></span>.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_16"><a class="link" href="#footnote_16">16</a></a></span>
          </div>

          <div class="normaltext">
          
          
          
          In order to implement Newton&#146;s method as a
          function, we must first
          express the idea of derivative.  Note that &#147;derivative,&#148; like
          average damping, is something that transforms a function into another
          function.  For instance, the derivative of the function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_609.png"></span> is the function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_610.png"></span>.  In general, if <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_611.png"></span> is a
          function and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_612.png"></span> is a small number, then the derivative <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_613.png"></span> of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_614.png"></span> is
          the function whose value at any number <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_615.png"></span> is given (in the limit of
          small <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_616.png"></span>) by
          <P><img src="img_javascript/latex_38.png"></P>
          Thus, we can express the idea of derivative (taking <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_617.png"></span> to be, say,
          0.00001) as the
          function

        <div style="position:absolute;display:none;" id="javascript_331_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction deriv(g) {\n   return function(x) {\n             return (g(x + dx) - g(x)) / dx;\n          }\n}\nvar dx = 0.00001;\n\n// example\n\nfunction cube(x) { return x * x * x; }\n\nderiv(cube)(5);','javascript_331','',event,1.0);">function deriv(g) {
   return function(x) {
             return (g(x + dx) - g(x)) / dx;
          }
}
var dx = 0.00001;</pre>

          along with the definition

          <div style="position:absolute;display:none;" id="javascript_332_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar dx = 0.00001;','javascript_332','',event,1.0);">var dx = 0.00001;</pre>
          </div>

          <div class="normaltext">
          
          Like 
          <span class="javascriptinline">average_damp</span>,
          <span class="schemeinline">deriv</span> is a
          function
          that takes a
          function
          as argument and returns a
          function
          as value.  For example,
          to approximate the derivative of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_618.png"></span> at 5 (whose exact
          value is 75) we can evaluate

        <div style="position:absolute;display:none;" id="javascript_333_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction deriv(g) {\n   return function(x) {\n             return (g(x + dx) - g(x)) / dx;\n          }\n}\nvar dx = 0.00001;\n          \nvar dx = 0.00001;\n          \nfunction cube(x) { return x * x * x; }\n\nderiv(cube)(5);','javascript_333','',event,1.0);">function cube(x) { return x * x * x; }

deriv(cube)(5);</pre>
        
          </div>

          <div class="normaltext">
          With the aid of <span class="schemeinline">deriv</span>, we can express Newton&#146;s method as a
          fixed-point process:

          <div style="position:absolute;display:none;" id="javascript_334_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfunction deriv(g) {\n   return function(x) {\n             return (g(x + dx) - g(x)) / dx;\n          }\n}\nvar dx = 0.00001;\n          \nfunction newton_transform(g) {\n   return function(x) {\n             return x - g(x) / deriv(g)(x);\n          }\n}\nfunction newtons_method(g,guess) {\n   return fixed_point(\n            newton_transform(g),guess);\n}','javascript_334','',event,1.0);">function newton_transform(g) {
   return function(x) {
             return x - g(x) / deriv(g)(x);
          }
}
function newtons_method(g,guess) {
   return fixed_point(
            newton_transform(g),guess);
}</pre>
              
              
          </div>
          <div class="normaltext">
          The <span class="javascriptinline">newton_transform</span>
          function
          expresses the formula at the
          beginning of this section, and <span class="javascriptinline">newtons_method</span> is readily defined
          in terms of this.  It takes as arguments a
          function
          that computes the
          function for which we want to find a zero, together with an initial
          guess.  For instance, to find the 
          
          square root of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_619.png"></span>, we can use
          Newton&#146;s method to find a zero of the function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_620.png"></span> starting with
          an initial guess of 1.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_17"><a class="link" href="#footnote_17">17</a></a></span>
          This provides yet another form of the square-root
          function:

          <div style="position:absolute;display:none;" id="javascript_335_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfunction deriv(g) {\n   return function(x) {\n             return (g(x + dx) - g(x)) / dx;\n          }\n}\nvar dx = 0.00001;\n          \nfunction newton_transform(g) {\n   return function(x) {\n             return x - g(x) / deriv(g)(x);\n          }\n}\nfunction newtons_method(g,guess) {\n   return fixed_point(\n            newton_transform(g),guess);\n}\n          \nfunction square(x) { return x * x; }\n                \nfunction sqrt(x) {\n   return newtons_method(\n            function(y) { return square(y) - x; },\n            1.0);\n}\n\n// example\n\nsqrt(9);','javascript_335','',event,1.0);">function sqrt(x) {
   return newtons_method(
            function(y) { return square(y) - x; },
            1.0);
}</pre>
          
          
          </div>

          <H4>Abstractions and first-class
              functions</H4>
            
          

          <div class="normaltext">
          We&#146;ve seen two ways to express the square-root
          computation as an instance of a more general method, once as a fixed-point
          search and once using Newton&#146;s method.  Since Newton&#146;s method
          was itself expressed as a fixed-point process,
          we actually saw two ways to compute square roots as fixed points.
          Each method begins with a function and finds a 
          
          fixed
          point of some transformation of the function.  We can express this
          general idea itself as a
          function:

          <div style="position:absolute;display:none;" id="javascript_336_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfunction fixed_point_of_transform(g,transform,guess) {\n   return fixed_point(transform(g),guess);\n}','javascript_336','',event,1.0);">function fixed_point_of_transform(g,transform,guess) {
   return fixed_point(transform(g),guess);
}</pre>
          
          </div>

          <div class="normaltext">
          This very general
          function
          takes as its arguments a
          function
          <span class="schemeinline">g</span>
          that computes some function, a
          function
          that transforms <span class="schemeinline">g</span>, and
          an initial guess.  The returned result is a fixed point of the
          transformed function.
          </div>

          <div class="normaltext">
          
          Using this abstraction, we can recast the first square-root
          computation from this section (where we look for
          a fixed point of the average-damped version of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_621.png"></span>)
          as an instance of this general method:

        <div style="position:absolute;display:none;" id="javascript_337_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfunction fixed_point_of_transform(g,transform,guess) {\n   return fixed_point(transform(g),guess);\n}\n          \nfunction average(x,y) {\n   return (x + y) / 2;\n}\n              \nfunction average_damp(f) {\n   return function(x) { \n             return average(x,f(x)); \n          }\n}\n          \nfunction sqrt(x) {\n   return fixed_point_of_transform(\n            function(y) { return x / y; },\n            average_damp,\n            1.0);\n}\n\n// example\n\nsqrt(9);','javascript_337','',event,1.0);">function sqrt(x) {
   return fixed_point_of_transform(
            function(y) { return x / y; },
            average_damp,
            1.0);
}</pre>
        
          </div>

          <div class="normaltext">
          
          Similarly, we can express the second square-root computation from this section
          (an instance
          of Newton&#146;s method that finds a fixed point of the
          Newton transform of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_622.png"></span>) as

              
              
          <div style="position:absolute;display:none;" id="javascript_338_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfunction fixed_point_of_transform(g,transform,guess) {\n   return fixed_point(transform(g),guess);\n}\n          \nfunction square(x) { return x * x; }\n                \nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfunction deriv(g) {\n   return function(x) {\n             return (g(x + dx) - g(x)) / dx;\n          }\n}\nvar dx = 0.00001;\n          \nfunction newton_transform(g) {\n   return function(x) {\n             return x - g(x) / deriv(g)(x);\n          }\n}\nfunction newtons_method(g,guess) {\n   return fixed_point(\n            newton_transform(g),guess);\n}\n          \nfunction sqrt(x) {\n   return fixed_point_of_transform(\n            function(y) { return square(y) - x; },\n            newton_transform,\n            1.0);\n}\n\n// example\n\nsqrt(5);','javascript_338','',event,1.0);">function sqrt(x) {
   return fixed_point_of_transform(
            function(y) { return square(y) - x; },
            newton_transform,
            1.0);
}</pre>
          </div>

          <div class="normaltext">
          We began section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')">1.3</a> with the observation
          that compound
          functions
          are a crucial abstraction mechanism, because they permit us to
          express general methods of computing as explicit elements in our
          programming language.  Now we&#146;ve seen how higher-order
          functions
          permit us to manipulate these general methods
          to create further abstractions.
          </div>
          
          <div class="normaltext">
          As programmers, we should be alert to opportunities to identify the
          underlying abstractions in our programs and to build upon them and
          generalize them to create more powerful abstractions.  This is not to
          say that one should always write programs in the most abstract way
          possible; expert programmers know how to choose the level of
          abstraction appropriate to their task.  But it is important to be able
          to think in terms of these abstractions, so that we can be ready to
          apply them in new contexts.  The significance of higher-order
          functions
          is that they enable us to represent these abstractions
          explicitly as elements in our programming language, so that they can
          be handled just like other computational elements.
          </div>

          <div class="normaltext">
          In general, programming languages impose restrictions on the ways in
          which computational elements can be manipulated.  Elements with the
          fewest restrictions are said to have 
          
          <em>first-class</em> status.  Some
          of the &#147;rights and privileges&#148; of first-class 
          elements are:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_18"><a class="link" href="#footnote_18">18</a></a></span>
          <ul>
            <li>They may be named by variables.
            </li>
            <li>They may be passed as arguments to
              functions.
            </li>
            <li>They may be returned as the results of
              functions.
            </li>
            <li>They may be included in data structures.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_19"><a class="link" href="#footnote_19">19</a></a></span>
            </li>
          </ul>
          </div>
          
          <div class="normaltext">
          
          
          JavaScript, 
          unlike other common programming languages, awards
          functions
          full first-class status.  This poses challenges for efficient
          implementation, but the resulting gain in expressive power is
          enormous.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_20"><a class="link" href="#footnote_20">20</a></a></span>
          </div>

          <div class="exercise">
<b>Exercise 1.41.</b> 
            Define a
            function
            <span class="schemeinline">cubic</span> that can be used together with the 
            <span class="javascriptinline">newtons_method</span>
            function
            in expressions of the form

        

        <div style="position:absolute;display:none;" id="javascript_340_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nvar tolerance = 0.00001;\n\nfunction fixed_point(f,first_guess) {\n   function close_enough(x,y) {\n      return abs(x - y) &lt; tolerance;\n   }\n   function try_with(guess) {\n      var next = f(guess);\n      if (close_enough(guess,next))\n           return next;\n      else return try_with(next);\n   }\n   return try_with(first_guess);\n}\n          \nfunction deriv(g) {\n   return function(x) {\n             return (g(x + dx) - g(x)) / dx;\n          }\n}\nvar dx = 0.00001;\n          \nfunction newton_transform(g) {\n   return function(x) {\n             return x - g(x) / deriv(g)(x);\n          }\n}\nfunction newtons_method(g,guess) {\n   return fixed_point(\n            newton_transform(g),guess);\n}\n          \n// cubic to be written by student; see EXERCISE 1.40\n          \nnewtons_method(cubic(a,b,c),1);','javascript_340','',event,1.0);">newtons_method(cubic(a,b,c),1);</pre>

            to approximate zeros of the cubic <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_623.png"></span>.
      <div style="position:absolute;display:none;" id="javascript_341_div"></div>
          </div>

          <div class="exercise">
<b>Exercise 1.42.</b>
            Define a
            function
            <span class="schemeinline">double</span> that takes a
            function
            of one
            argument as argument and
            returns a
            function
            that applies the original
            function
            twice.  For
            example, if <span class="schemeinline">inc</span> is a
            function
            that adds 1 to its argument,
            then <span class="schemeinline">(double inc)</span> should be a
            function
            that adds 2.  What
            value is returned by

        

        <div style="position:absolute;display:none;" id="javascript_343_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// double to be written by student; see EXERCISE 1.41\n          \nfunction inc(n) {\n   return n + 1;\n}\n          \ndouble(double(double))(inc)(5);','javascript_343','',event,1.0);">double(double(double))(inc)(5);</pre>
    <div style="position:absolute;display:none;" id="javascript_344_div"></div>
          </div>

          <div class="exercise">
<b>Exercise 1.43.</b><a name="ex:compose"></a>
            
            
            Let <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_624.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_625.png"></span> be two one-argument functions.  The <em>composition</em>
            <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_626.png"></span> after <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_627.png"></span> is defined to be the function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_628.png"></span>.
            Define a
            function
            <span class="schemeinline">compose</span> that implements composition.  For
            example, if <span class="schemeinline">inc</span> is a
            function
            that adds 1 to its argument,

        

        <div style="position:absolute;display:none;" id="javascript_346_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// compose to be written by student; see EXERCISE 1.42\n          \nfunction square(x) { return x * x; }\n                \nfunction inc(n) {\n   return n + 1;\n}\n          \ncompose(square,inc)(6);','javascript_346','',event,1.0);">compose(square,inc)(6);</pre>
            returns 49.
        <div style="position:absolute;display:none;" id="javascript_347_div"></div>
          </div>

          <div class="exercise">
<b>Exercise 1.44.</b> 
            
            If <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_629.png"></span> is a numerical function and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_630.png"></span> is a positive integer, then we
            can form the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_631.png"></span>th repeated application of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_632.png"></span>, which is defined to be
            the function whose value at <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_633.png"></span> is <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_634.png"></span>.  For
            example, if <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_635.png"></span> is the function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_636.png"></span>,
            then the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_637.png"></span>th repeated application of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_638.png"></span> is
            the function <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_639.png"></span>.  If <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_640.png"></span> is the operation of
            squaring a number, then the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_641.png"></span>th repeated application of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_642.png"></span> is the
            function that raises its argument to the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_643.png"></span>th power.  Write a
            function
            that takes as inputs a
            function
            that computes <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_644.png"></span> and a
            positive integer <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_645.png"></span> and returns the
            function
            that computes the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_646.png"></span>th
            repeated application of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_647.png"></span>.  Your
            function
            should be able to be used
            as follows:

        

        <div style="position:absolute;display:none;" id="javascript_349_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction square(x) { return x * x; }\n                \n// repeated to be written by student; see EXERCISE 1.43\n          \nrepeated(square,2)(5);','javascript_349','',event,1.0);">repeated(square,2)(5);</pre>

            Hint: You may find it convenient to use <span class="schemeinline">compose</span> from
            exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#ex:compose">1.43</a>.
            <a name="ex:repeated"></a>
        <div style="position:absolute;display:none;" id="javascript_350_div"></div>
          </div>

          <div class="exercise">
<b>Exercise 1.45.</b><a name="ex:smooth"></a> 
            
            
            
            The idea of <em>smoothing</em> a function is an important concept in
            signal processing.  If <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_648.png"></span> is a function and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_649.png"></span> is some small number,
            then the smoothed version of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_650.png"></span> is the function whose value at a
            point <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_651.png"></span> is the average of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_652.png"></span>, <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_653.png"></span>, and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_654.png"></span>.  Write a
            function
            <span class="schemeinline">smooth</span> that takes as input a
            function
            that computes
            <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_655.png"></span> and returns a
            function
            that computes the smoothed <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_656.png"></span>.  It is
            sometimes valuable to repeatedly smooth a function (that is, smooth
            the smoothed function, and so on) to obtained the <em><span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_657.png"></span>-fold
              smoothed function</em>.  Show how to generate the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_658.png"></span>-fold smoothed
            function of any given function using <span class="schemeinline">smooth</span> and <span class="schemeinline">repeated</span>
            from exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#ex:repeated">1.44</a>.
     <div style="position:absolute;display:none;" id="javascript_351_div"></div>
     
          </div>

          <div class="exercise">
<b>Exercise 1.46.</b>
            We saw in section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#sec:proc-general-methods">1.3.3</a>
            that attempting to compute square roots by naively finding a
            fixed point of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_659.png"></span> does not converge, and that this can be
            fixed by average damping.  The same method works for finding cube
            roots as fixed points of the average-damped <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_660.png"></span>.
            Unfortunately, the process does not work for 
            
            
            fourth roots—a single
            average damp is not enough to make a fixed-point search for <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_661.png"></span> converge.  On the other hand, if we average damp twice (i.e.,
            use the average damp of the average damp of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_662.png"></span>) the
            fixed-point search does converge.  Do some experiments to determine
            how many average damps are required to compute 
            
            
            <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_665.png"></span>th roots as a
            fixed-point search based upon repeated average damping of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_666.png"></span>.  Use this to implement a simple
            function
            for computing
            <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_667.png"></span>th roots using 
            <span class="javascriptinline">fixed_point</span>, 
            <span class="javascriptinline">average_damp</span>, and the <span class="schemeinline">repeated</span>
            function
            of exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#ex:repeated">1.44</a>.
            Assume that any arithmetic operations you need are available as primitives.
            <a name="ex:nth-roots"></a>
          </div>

          <div class="exercise">
<b>Exercise 1.47.</b>
            
            
            
            
            Several of the numerical methods described in this chapter are instances
            of an extremely general computational strategy known as <em>iterative
              improvement</em>.  Iterative improvement says that, to compute something,
            we start with an initial guess for the answer, test if the guess is
            good enough, and otherwise improve the guess and continue the process
            using the improved guess as the new guess.  Write a
            function
            <span class="schemeinline">iterative-improve</span> that takes two
            functions
            as arguments: a method
            for telling whether a guess is good enough and a method for improving
            a guess.  <span class="javascriptinline">The function </span>iterative_improve should return as its value a
            function
            that takes a guess as argument and keeps improving the guess
            until it is good enough.  Rewrite the <span class="schemeinline">sqrt</span>
            function
            of
            section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_1.html')" href="#sec:sqrt">1.1.7</a> and the 
            <span class="javascriptinline">fixed_point</span>
            function
            of
            section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#sec:proc-general-methods">1.3.3</a> in terms of <span class="javascriptinline">iterative_improve</span>.
          </div>
          
          
        
      <div class="navbar" align="center">
<hr>
<a class="link" onclick="window.displayManager.show('section_1_2.html')">previous section</a>&nbsp;&nbsp;&nbsp;<a class="link" onclick="window.displayManager.show('chapter_1.html')">this chapter</a>&nbsp;&nbsp;&nbsp;<hr>
</div><strong class="footnote">Footnotes</strong><div class="footnote">
<a name="footnote_1"><sup><a class="link" href="#footnote_origin_1">1</a></sup></a>This series,
            
            
            usually written in the equivalent form 
            <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_452.png"></span>, 
            is due to Leibniz.  We&#146;ll see how
            to use this as the basis for some fancy numerical tricks in
            section&nbsp;.</div><div class="footnote">
<a name="footnote_2"><sup><a class="link" href="#footnote_origin_2">2</a></sup></a>Notice
            that we have used block structure (section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_1.html')" href="#sec:block-structure">1.1.8</a>) to
            embed the definitions of 
            <span class="javascriptinline">pi_next</span> and 
            <span class="javascriptinline">pi_term</span> within <span class="javascriptinline">pi_sum</span>, since these
            functions
            are unlikely to be useful for any
            other purpose.  We will see how to get rid of them altogether in
            section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#sec:lambda">1.3.2</a>.</div><div class="footnote">
<a name="footnote_3"><sup><a class="link" href="#footnote_origin_3">3</a></sup></a>The intent of
                exercises&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#ex:product">1.32</a>–<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#ex:filtered-accumulate">1.34</a> is to
                demonstrate the expressive power that is attained by using an
                appropriate abstraction to consolidate many seemingly disparate
                operations.  However, though accumulation and filtering are elegant
                ideas, our hands are somewhat tied in using them at this point since
                we do not yet have data structures to provide suitable means of
                combination for these abstractions.  We will return to these ideas in
                section&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#sec:sequences-conventional-interfaces">2.2.3</a> when we show how
                to use <em>sequences</em> as interfaces for combining filters and
                accumulators to build even more powerful abstractions.  We will see
                there how these methods really come into their own as a powerful and
                elegant approach to designing programs.</div><div class="footnote">
<a name="footnote_4"><sup><a class="link" href="#footnote_origin_4">4</a></sup></a>This formula was discovered by the 
                seventeenth-century
                
                English mathematician John Wallis.</div><div class="footnote">
<a name="footnote_6"><sup><a class="link" href="#footnote_origin_6">6</a></sup></a>The idea to introduce functions without naming
              them plays a central role in the 
            
            <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_486.png"></span> calculus, a
            
            mathematical formalism introduced by the mathematical logician Alonzo
            Church (1941).  Church developed the <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_487.png"></span> calculus 
            to provide a
            rigorous foundation for studying the notions of function and function
            application.  
            The <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_488.png"></span> calculus has become a basic tool for
            mathematical investigations of the semantics of programming
            languages.</div><div class="footnote">
<a name="footnote_7"><sup><a class="link" href="#footnote_origin_7">7</a></sup></a>This peculiar scoping
                rule makes it rather difficult to directly 
                define a substitution model
                for functions with <span class="javascriptinline">var</span>.
                The simplest way to provide a substitution model in this
                case is to first convert the body to an equivalent form that
                uses function definition expressions as shown above.</div><div class="footnote">
<a name="footnote_9"><sup><a class="link" href="#footnote_origin_9">9</a></sup></a>We have used 0.001 as a 
            representative &#147;small&#148; number to indicate a
            tolerance for the acceptable error in a calculation.  
            The appropriate
            tolerance for a real calculation depends upon the problem to be solved
            and the limitations of the computer and the algorithm.  This is often
            
            a very subtle consideration, requiring help from a numerical analyst
            or some other kind of magician.</div><div class="footnote">
<a name="footnote_10"><sup><a class="link" href="#footnote_origin_10">10</a></sup></a>This

            can be accomplished using <span class="schemeinline">error</span>, which takes as
            arguments a number of items that are printed as error
            messages.</div><div class="footnote">
<a name="footnote_11"><sup><a class="link" href="#footnote_origin_11">11</a></sup></a>Try this during a boring lecture: 
            Set your calculator to
            
            
            
            radians mode and then repeatedly press the <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_531.png"></span> button until you
            obtain the fixed point.</div><div class="footnote">
<a name="footnote_12"><sup><a class="link" href="#footnote_origin_12">12</a></sup></a><span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_537.png"></span>
            
            
            (pronounced &#147;maps to&#148;) is
            the mathematician&#146;s way of writing <span class="schemeinline">lambda</span>.
            <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_540.png"></span> means <span class="schemeinline">(lambda(y) (/ x y))</span>, 
            that is, the function whose value at <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_541.png"></span> is 
            <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_542.png"></span>.</div><div class="footnote">
<a name="footnote_13"><sup><a class="link" href="#footnote_origin_13">13</a></sup></a>Observe that this is a combination 
            whose operator is itself
            
            
            
            a combination.  Exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_1_1.html')" href="#ex:a-plus-abs-b">1.4</a> already demonstrated
            the ability to form such combinations, but that was only a toy
            example.  Here we begin to see the real need for such
            combinations—when applying a
            function
            that is obtained as the value
            returned by a higher-order
            function.</div><div class="footnote">
<a name="footnote_14"><sup><a class="link" href="#footnote_origin_14">14</a></sup></a>See exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#ex:nth-roots">1.46</a> 
            for a further generalization.</div><div class="footnote">
<a name="footnote_15"><sup><a class="link" href="#footnote_origin_15">15</a></sup></a>Elementary 
            calculus books usually describe Newton&#146;s
            method in terms of the sequence of approximations
            <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_605.png"></span>.  Having language for talking about
            processes and using the idea of fixed points simplifies the description
            of the method.</div><div class="footnote">
<a name="footnote_16"><sup><a class="link" href="#footnote_origin_16">16</a></sup></a>Newton&#146;s 
            method does not always converge to an answer, but
            it can be shown that in favorable cases each iteration doubles the
            number-of-digits accuracy of the approximation to the solution.
            In such cases, 
            
            
            Newton&#146;s method will converge much more
            rapidly than the half-interval method.</div><div class="footnote">
<a name="footnote_17"><sup><a class="link" href="#footnote_origin_17">17</a></sup></a>For finding square roots, 
            Newton&#146;s method converges rapidly to the
            correct solution from any starting point.</div><div class="footnote">
<a name="footnote_18"><sup><a class="link" href="#footnote_origin_18">18</a></sup></a>The notion of first-class status of 
            programming-language 
            elements is due to the British computer scientist Christopher
            Strachey (1916–1975).</div><div class="footnote">
<a name="footnote_19"><sup><a class="link" href="#footnote_origin_19">19</a></sup></a>We&#146;ll see
                examples of this after we introduce data structures in chapter&nbsp;2.</div><div class="footnote">
<a name="footnote_20"><sup><a class="link" href="#footnote_origin_20">20</a></sup></a>The major implementation cost of first-class
            functions
            is that allowing
            functions
            to be returned as values
            requires reserving storage for a
            function&#146;s free variables even while
            the
            function
            is not executing.  In the Scheme implementation we will
            study in section&nbsp;, these variables are stored in the
            function&#146;s environment.</div>

<div class="navbar" align="center">
<a class="link" onclick="window.displayManager.show('section_2_1.html')">previous section</a>&nbsp;&nbsp;&nbsp;<a class="link" onclick="window.displayManager.show('chapter_2.html')">this chapter</a>&nbsp;&nbsp;&nbsp;<a class="link" onclick="window.displayManager.show('section_2_3.html')">next section</a><hr>
</div><h2><a name="section_2_2">2.2&nbsp;Hierarchical Data and the Closure Property</a></h2>
    

    <div class="subtoc">
<strong>In this section</strong><p></p>
<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#subsection_2_2_1">2.2.1&nbsp;
        Representing Sequences
      </a><br><a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#subsection_2_2_2">2.2.2&nbsp;
        Hierarchical Structures
      </a><br><a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#subsection_2_2_3">2.2.3&nbsp;
        Sequences as Conventional Interfaces
      </a><br><a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#subsection_2_2_4">2.2.4&nbsp;
        Example: A Picture Language
      </a><br>
</div>

    <a name="sec:hierarchical-data"></a>
    <div class="normaltext">
      As we have seen, pairs provide a primitive &#147;glue&#148; that we can use to
      construct compound data objects.
      Figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:first-box-and-pointer">2.2</a> shows a standard way to
      visualize a 
      
      pair—in this case, the pair formed by <span class="javascriptinline">pair(1,2)</span>.
      In this representation, which is called 
      
      <em>box-and-pointer
        notation</em>, each object is shown as a 
      
      <em>pointer</em> to a box.  The box
      for a primitive object contains a representation of the object.  For
      example, the box for a number contains a numeral.  The box for a pair
      is actually a double box, the left part containing (a pointer to) the
      <span class="javascriptinline">head</span> of the pair and the right part containing the <span class="javascriptinline">tail</span>.
    </div>

    <div class="normaltext">
      We have already seen that <span class="javascriptinline">pair</span> can be used to combine not
      only numbers but pairs as well.  (You made use of this fact, or
      should have, in doing exercises&nbsp;<a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#ex:segments1">2.2</a>
      and&nbsp;<a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#ex:rectangles">2.3</a>.)  As a consequence, pairs provide a universal
      building block from which we can construct all sorts of data
      structures.  Figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:box-and-pointer-two-ways">2.3</a> 
      shows two ways to use pairs to combine the numbers 1, 2, 3, and 4.

              <p><div align="center"><table width="100%">
<tr><td align="center">
<img src="img_original/ch2-Z-G-11.gif" border="0">
                <a name="fig:first-box-and-pointer"></a>
                
              </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  2</b>&nbsp;&nbsp;&nbsp;Box-and-pointer representation of <span class="javascriptinline">pair(1,2)</span>.
                </div></caption>
<tr><td></td></tr>
</table></div></p>

              <p><div align="center"><table width="100%">
<tr><td align="center">
<img src="img_original/ch2-Z-G-12.gif" border="0">
                <a name="fig:box-and-pointer-two-ways"></a>
                
              </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  3</b>&nbsp;&nbsp;&nbsp;Two ways to combine 1, 2, 3, and 4 using pairs.
                </div></caption>
<tr><td></td></tr>
</table></div></p>
    </div>


    <div class="normaltext">
      The ability to create pairs whose elements are pairs is the essence of
      list structure&#146;s importance as a representational tool.  We refer to
      this ability as the 
      
      
      <em>closure property</em> of <span class="javascriptinline">pair</span>.  In general,
      an operation for combining data objects satisfies the closure property
      if the results of combining things with that operation can themselves
      be combined using the same 
      operation.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_1"><a class="link" href="#footnote_1">1</a></a></span>
      Closure is the key to power in
      any means of combination because it permits us to create 
      
      
      <em>
        hierarchical</em> structures—structures made up of parts, which
      themselves are made up of parts, and so on.
    </div>

    <div class="normaltext">
      From the outset of chapter&nbsp;1, we&#146;ve made essential use of closure in
      dealing with
      functions, because all but the very simplest programs
      rely on the fact that the elements of a combination can themselves be
      combinations.  In this section, we take up the consequences of closure
      for compound data.  We describe some conventional techniques for using
      pairs to represent sequences and trees, and we exhibit a graphics
      language that illustrates closure in a vivid 
      way.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_2"><a class="link" href="#footnote_2">2</a></a></span>
    </div>

    <h3><a name="subsection_2_2_1">2.2.1&nbsp;
        Representing Sequences
      </a></h3>
      

      <a name="sec:sequences"></a>
      <div class="normaltext">

              <p><div align="center"><table width="100%">
<tr><td align="center">
<img src="img_original/ch2-Z-G-13.gif" border="0">
                <a name="fig:sequence-of-pairs"></a>
                
              </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  4</b>&nbsp;&nbsp;&nbsp;The sequence 1, 2, 3, 4 represented as a chain of pairs.
                </div></caption>
<tr><td></td></tr>
</table></div></p>

        One of the useful structures we can build with pairs is a 
        
        
        
        <em>
          sequence</em>—an ordered collection of data objects.  There are, of
        course, many ways to represent sequences in terms of pairs.  One
        particularly straightforward representation is illustrated in
        figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:sequence-of-pairs">2.4</a>, where the sequence 1, 2, 3, 4 is
        represented as a chain of pairs.  The <span class="javascriptinline">head</span> of each pair is the
        corresponding item in the chain, and the <span class="javascriptinline">tail</span> of the pair is
        the next pair in the chain.  The <span class="javascriptinline">tail</span> of the final pair
        signals the end of the sequence by pointing to a distinguished
        value that is not a pair,
        represented in box-and-pointer diagrams as a diagonal line
        
        and in programs as the value of 
        
        
        JavaScript&#146;s value <span class="javascriptinline">[]</span>.
        The entire sequence is constructed by nested <span class="javascriptinline">pair</span> operations:

        <div style="position:absolute;display:none;" id="javascript_404_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\npair(1,\n     pair(2,\n          pair(3,\n               pair(4,[]))))','javascript_404','',event,1.0);">pair(1,
     pair(2,
          pair(3,
               pair(4,[]))))</pre>
      </div>

      <div class="normaltext">
        Such a sequence of pairs, formed by nested <span class="javascriptinline">pair</span>es, is called a
        
        <em>list</em>, and JavaScript provides a
        primitive called 
        
        
        <span class="schemeinline">list</span> to help in constructing 
        lists.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_3"><a class="link" href="#footnote_3">3</a></a></span>
      </div>

      <div class="normaltext">
        The above sequence could be produced by <span class="javascriptinline">list(1,2,3,4)</span>.  In
        general,

        <form name="form_405" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_405.png"></form>

        is equivalent to

        <form name="form_406" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_406.png"></form>
      </div>

      
          <div class="normaltext">
          Our implementation of <span class="javascriptinline">pair</span> employs
          JavaScript arrays. Thus, <span class="javascriptinline">pair(1,2)</span>
          is printed as <span class="javascriptinline">[1,2]</span>, which is an
          array with the elements 1 and 2. The data object in
          figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:sequence-of-pairs">2.4</a> 
          is printed as 
          <span class="javascriptinline">[1,[2,[3,[4,[]]]]]</span>:
          </div>
        

        <div class="normaltext">
        <div style="position:absolute;display:none;" id="javascript_407_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar one_through_four = list(1,2,3,4);\n\n// example\n\none_through_four','javascript_407','',event,1.0);">var one_through_four = list(1,2,3,4);</pre>

        

      </div>




    <span style="color:black" title=""></span>
  

      <div class="normaltext">
        We can think of 
        
        
        <span class="javascriptinline">head</span> as selecting the first item in the list, and
        of 
        
        <span class="javascriptinline">tail</span> as selecting the sublist consisting of all but the first
        item.  Nested applications of <span class="javascriptinline">head</span> and <span class="javascriptinline">tail</span> can be used to
        extract the second, third, and subsequent items in the
        list.
        The constructor 
        
        <span class="javascriptinline">pair</span> makes a list like the original one,
        but with an additional item at the beginning.

        <div style="position:absolute;display:none;" id="javascript_409_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar one_through_four = list(1,2,3,4);\n          \nhead(one_through_four)','javascript_409','',event,1.0);">head(one_through_four)</pre>



        <div style="position:absolute;display:none;" id="javascript_410_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar one_through_four = list(1,2,3,4);\n          \ntail(one_through_four)','javascript_410','',event,1.0);">tail(one_through_four)</pre>

        <div style="position:absolute;display:none;" id="javascript_411_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar one_through_four = list(1,2,3,4);\n          \nhead(tail(one_through_four))','javascript_411','',event,1.0);">head(tail(one_through_four))</pre>

        <div style="position:absolute;display:none;" id="javascript_412_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar one_through_four = list(1,2,3,4);\n          \npair(10,one_through_four)','javascript_412','',event,1.0);">pair(10,one_through_four)</pre>




        <div style="position:absolute;display:none;" id="javascript_413_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar one_through_four = list(1,2,3,4);\n          \npair(5,one_through_four)','javascript_413','',event,1.0);">pair(5,one_through_four)</pre>

      </div>

      
      <div class="normaltext">
        The value <span class="javascriptinline">[]</span>, 
        used to terminate the chain of pairs, can be
        thought of as a sequence of no elements, the 
        
        
        <em>empty list</em>.
      </div>
        

      <H4>List operations</H4>
        
      

      
      
      <div class="normaltext">
        The use of pairs to represent sequences of elements as lists is
        accompanied by conventional programming techniques for manipulating
        lists by successively 
        
        
        &#147;<span class="javascriptinline">tail</span>ing down&#148; the lists.  For example,
        the
        function
        
        <span class="javascriptinline">list_ref</span> takes as arguments a list and a number
        <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_692.png"></span> and returns the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_693.png"></span>th item of the list.  It is customary to
        number the elements of the list beginning with 0.  The method for
        computing <span class="javascriptinline">list_ref</span> is the following:

        <ul>
          <li>For <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_694.png"></span>, <span class="javascriptinline">list_ref</span> should return the <span class="javascriptinline">head</span> of the list.
          </li>n
          <li>Otherwise, <span class="javascriptinline">list_ref</span> should return  the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_695.png"></span>st item of the
            <span class="javascriptinline">tail</span> of the list.
          </li>
        </ul>

        <div style="position:absolute;display:none;" id="javascript_414_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n\n// example\n\nvar squares = list(1,4,9,16,25);\nlist_ref(squares,3);','javascript_414','',event,1.0);">function list_ref(items,n) {
   if (n === 0)
      return head(items);
   else return list_ref(tail(items),n - 1);
}</pre>

        

        

      </div>

      <div class="normaltext">
        Often we <span class="javascriptinline">tail</span> down the whole list.  To aid in this, our JavaScript environment includes
          a predicate
        
        
        <span class="javascriptinline">is_empty_list</span>, which tests whether its argument is
        the empty list.  The
        function
        
        
        <span class="schemeinline">length</span>, which
        returns the number of items in a list, illustrates this typical
        pattern of use:

        <div style="position:absolute;display:none;" id="javascript_417_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction length(items) {\n   if (is_empty_list(items))\n      return 0;\n   else return 1 + length(tail(items));\n}\n\n// example\n\nvar odds = list(1,3,5,7);\n\nlength(odds);','javascript_417','',event,1.0);">function length(items) {
   if (is_empty_list(items))
      return 0;
   else return 1 + length(tail(items));
}</pre>

        

        
      </div>

      <div class="normaltext">
        The <span class="schemeinline">length</span>
        function
        implements a simple recursive plan. The
        reduction step is:

        <ul>
          <li>The <span class="schemeinline">length</span> of any list is 1 plus the <span class="schemeinline">length</span> of the
            <span class="javascriptinline">tail</span> of the list.
          </li>
        </ul>
      </div>

      <div class="normaltext">
        This is applied successively until we reach the base case:

        <ul>
          <li>The <span class="schemeinline">length</span> of the empty list is 0.
          </li>
        </ul>
      </div>

      <div class="normaltext">
        We could also compute <span class="schemeinline">length</span> in an iterative style:

        <div style="position:absolute;display:none;" id="javascript_420_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction length(items) {\n   function length_iter(a,count) {\n      if (is_empty_list(a))\n         return count;\n      else return length_iter(tail(a),count + 1);\n   }\n   return length_iter(items,0);\n}\n\n// example\n\nvar odds = list(1,3,5,7);\n\nlength(odds);','javascript_420','',event,1.0);">function length(items) {
   function length_iter(a,count) {
      if (is_empty_list(a))
         return count;
      else return length_iter(tail(a),count + 1);
   }
   return length_iter(items,0);
}</pre>
      </div>

      <div class="normaltext">
        Another conventional programming technique is to 
        
        
        &#147;<span class="javascriptinline">pair</span> up&#148; an
        answer list while <span class="javascriptinline">tail</span>ing down a list, as in the
        function
        
        
        <span class="schemeinline">append</span>, which takes two lists as arguments and combines their
        elements to make a new list:

        <div style="position:absolute;display:none;" id="javascript_421_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n          \nvar squares = list(1,4,9,16,25);\n          \nvar odds = list(1,3,5,7);\n          \nappend(squares,odds)','javascript_421','',event,1.0);">append(squares,odds)</pre>

        

        <div style="position:absolute;display:none;" id="javascript_423_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n          \nvar squares = list(1,4,9,16,25);\n          \nvar odds = list(1,3,5,7);\n          \nappend(odds,squares)','javascript_423','',event,1.0);">append(odds,squares)</pre>
      </div>

      <div class="normaltext">
        <span class="schemeinline">Append</span> is also implemented using a recursive plan.  To <span class="schemeinline">append</span>
        lists <span class="schemeinline">list1</span> and <span class="schemeinline">list2</span>, do the following:

        <ul>
          <li>If <span class="schemeinline">list1</span> is the empty list, then the result is just <span class="schemeinline">list2</span>.
          </li>
          <li>Otherwise, <span class="schemeinline">append</span> the <span class="javascriptinline">tail</span> of <span class="schemeinline">list1</span> and 
            <span class="schemeinline">list2</span>, and <span class="javascriptinline">pair</span> the <span class="javascriptinline">head</span> of <span class="schemeinline">list1</span> onto the result:
          </li>
        </ul>

        <div style="position:absolute;display:none;" id="javascript_424_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n\n// example\n\nvar squares = list(1,4,9,16,25);\nvar odds = list(1,3,5,7);\nappend(squares,odds)','javascript_424','',event,1.0);">function append(list1,list2) {
   if (is_empty_list(list1))
      return list2;
   else return pair(head(list1),append(tail(list1),list2));
}</pre>
      </div>

      <div class="exercise">
<b>Exercise 2.17.</b><a name="ex:last"></a> 
        Define a
        function

        
        
        <span class="javascriptinline">last_pair</span> that returns the list that contains only
        the last element of a given (nonempty) list:

        <div style="position:absolute;display:none;" id="javascript_425_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// last_pair to be given by student\nlast_pair(list(23,72,149,34))','javascript_425','',event,1.0);">// last_pair to be given by student
last_pair(list(23,72,149,34))</pre>
    <div style="position:absolute;display:none;" id="javascript_426_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.18.</b><a name="ex:reverse"></a>
        Define a
        function

        
        
        <span class="schemeinline">reverse</span> that takes a list as argument and
        returns a list of the same elements in reverse order:

        

        <div style="position:absolute;display:none;" id="javascript_428_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// reverse to be given by student\n          \nreverse(list(1,4,9,16,25))','javascript_428','',event,1.0);">reverse(list(1,4,9,16,25))</pre>
    <div style="position:absolute;display:none;" id="javascript_429_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.19.</b> 
        <p>
          Consider the 
          
          change-counting program of
          section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_2.html')" href="#sec:tree-recursion">1.2.2</a>.  It would be nice to be able to
          easily change the currency used by the program, so that we could
          compute the number of ways to change a British pound, for example.  As
          the program is written, the knowledge of the currency is distributed
          partly into the
          function
          <span class="javascriptinline">first_denomination</span> and partly into the
          function
          <span class="javascriptinline">count_change</span> (which knows that there are five
          kinds of U.S. coins).  It would be nicer to be able to
          supply a list of coins to be used for making change.
        </p>
        <p>
          We want to rewrite the
          function
          <span class="schemeinline">cc</span> so that its
          second argument is a list of the values of the
          coins to use rather than an integer specifying which coins to use.  We
          could then have lists that defined each kind of currency:
        <div style="position:absolute;display:none;" id="javascript_430_div"></div><pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar us_coins = list(50,25,10,5,1);\nvar uk_coins = list(100,50,20,10,5,2,1,0.5);','javascript_430','',event,1.0);">var us_coins = list(50,25,10,5,1);
var uk_coins = list(100,50,20,10,5,2,1,0.5);</pre>

          We could then call <span class="schemeinline">cc</span> as follows:

        <div style="position:absolute;display:none;" id="javascript_431_div"></div><pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// first_denomination, except_first_denomination\n// and no_more to be given by student\n          \nfunction cc(amount,coin_values) {\n   if (amount === 0) return 1;\n   else if (amount &lt; 0 || no_more(coin_values)) return 0;\n   else return cc(amount,except_first_denomination(coin_values))\n               +\n               cc(amount - first_denomination(coin_values),\n                  coin_values);\n}\n          \nvar us_coins = list(50,25,10,5,1);\nvar uk_coins = list(100,50,20,10,5,2,1,0.5);\n          \ncc(100,us_coins)','javascript_431','',event,1.0);">cc(100,us_coins)</pre>

          To do this will require changing the program <span class="schemeinline">cc</span> somewhat.  It will
          still have the same form, but it will access its second argument
          differently, as follows:

;; first define first-denomination, except-first-denomination, and no-more

// first define first_denomination, except_first_denomination, and no_more

        

        <div style="position:absolute;display:none;" id="javascript_433_div"></div><pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// first_denomination, except_first_denomination\n// and no_more to be given by student\n          \nfunction cc(amount,coin_values) {\n   if (amount === 0) return 1;\n   else if (amount &lt; 0 || no_more(coin_values)) return 0;\n   else return cc(amount,except_first_denomination(coin_values))\n               +\n               cc(amount - first_denomination(coin_values),\n                  coin_values);\n}','javascript_433','',event,1.0);">function cc(amount,coin_values) {
   if (amount === 0) return 1;
   else if (amount &lt; 0 || no_more(coin_values)) return 0;
   else return cc(amount,except_first_denomination(coin_values))
               +
               cc(amount - first_denomination(coin_values),
                  coin_values);
}</pre>

        </p>
        <p>
          Define the
          functions
          <span class="javascriptinline">first_denomination</span>, <span class="javascriptinline">except_first_denomination</span>, and <span class="javascriptinline">no_more</span> in terms of primitive
          operations on list structures.  Does the order of the list <span class="javascriptinline">coin_values</span> affect the answer produced by <span class="schemeinline">cc</span>?  Why or why not?
        </p>
    <div style="position:absolute;display:none;" id="javascript_434_div"></div>
      </div>

      
      <div class="exercise">
<b>Exercise 2.21.</b><a name="ex:dotted-arglist"></a>
        
        
        
        
        <p>
        The
        function
        <span class="javascriptinline">list</span> takes an arbitrary number
        of arguments. In order to define such a
        function, we make use of two features of JavaScript. Firstly, note that
        the JavaScript interpreter tolerates additional arguments to be passed to
        any function. Thus,
        <div style="position:absolute;display:none;" id="javascript_443_div"></div><pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction f(x,y) {\n   return x + y;\n}\nf(1,2,3,4);','javascript_443','',event,1.0);">function f(x,y) {
   return x + y;
}
f(1,2,3,4);</pre>
        will return the number 3. 
        </p>
        <p>
Secondly, the variable 
        <span class="javascriptinline">arguments</span> can be used in any
        function body to refer to all actual arguments. The actual arguments
        are represented by 
        <span class="javascriptinline">arguments</span> as an array, and thus
        available using the notation
        <span class="javascriptinline">arguments[0]</span>, 
        <span class="javascriptinline">arguments[1]</span>, etc.
        For example,
        <div style="position:absolute;display:none;" id="javascript_444_div"></div><pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction g() {\n   return arguments[0] + arguments[1] + arguments[2];\n}\nf(1,2,3,4);','javascript_444','',event,1.0);">function g() {
   return arguments[0] + arguments[1] + arguments[2];
}
f(1,2,3,4);</pre>
        will return the number 6.
        </p>
        <p>
        Use this notation
        to write a
        function
        <span class="javascriptinline">same_parity</span> that takes one or more integers
        and returns a list of all the arguments that have the same even-odd
        parity as the first argument.  For example,
        

        <div style="position:absolute;display:none;" id="javascript_446_div"></div><pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// same_parity to be given by student\n          \nsame_parity(1,2,3,4,5,6,7)','javascript_446','',event,1.0);">same_parity(1,2,3,4,5,6,7)</pre>
        returns <span class="javascriptinline">[1,3,5,7]</span>, and
        <div style="position:absolute;display:none;" id="javascript_447_div"></div><pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// same_parity to be given by student\n          \nsame_parity(2,3,4,5,6,7)','javascript_447','',event,1.0);">same_parity(2,3,4,5,6,7)</pre>
        returns <span class="javascriptinline">[2,4,6]</span>.
        </p>
      </div>
        

      <H4>Mapping over lists</H4>
        
      

      
      
      <div class="normaltext">
        One extremely useful operation is to apply some transformation
        to each element in a list and generate the list of results.
        For instance, the following
        function
        scales each number in a list by
        a given factor:

        <div style="position:absolute;display:none;" id="javascript_448_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction scale_list(items,factor) {\n   if (is_empty_list(items)) return [];\n   else return pair(head(items) * factor,\n                    scale_list(tail(items),factor));\n}\n\n// example\n\nscale_list(list(1,2,3,4,5),10)','javascript_448','',event,1.0);">function scale_list(items,factor) {
   if (is_empty_list(items)) return [];
   else return pair(head(items) * factor,
                    scale_list(tail(items),factor));
}</pre>

        <div style="position:absolute;display:none;" id="javascript_449_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction scale_list(items,factor) {\n   if (is_empty_list(items)) return [];\n   else return pair(head(items) * factor,\n                    scale_list(tail(items),factor));\n}\n          \nscale_list(list(1,2,3,4,5),10)','javascript_449','',event,1.0);">scale_list(list(1,2,3,4,5),10)</pre>
      </div>

      <div class="normaltext">
        We can abstract this general idea and capture it as a common pattern
        expressed as a higher-order
        function, just as in
        section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')">1.3</a>.  The higher-order
        function
        here is called <span class="schemeinline">map</span>.  The function <span class="javascriptinline">map</span> takes as arguments a
        function
        of one argument
        and a list, and returns a list of the results produced by
        applying the
        function
        to each element in the list:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_7"><a class="link" href="#footnote_7">7</a></a></span>

        
        <div style="position:absolute;display:none;" id="javascript_454_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}','javascript_454','',event,1.0);">function map(fun,items) {
   if (is_empty_list(items)) 
      return [];
   else return pair(fun(head(items)),
                    map(fun,tail(items)));
}</pre>

        <div style="position:absolute;display:none;" id="javascript_455_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction abs(x) {\n   if (x &gt;= 0) \n      return x;\n   else \n      return -x;\n}\n                \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nmap(abs,list(-10,2.5,-11.6,17))','javascript_455','',event,1.0);">map(abs,list(-10,2.5,-11.6,17))</pre>

        <div style="position:absolute;display:none;" id="javascript_456_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nmap(function(x) { return x * x; },\n    list(1,2,3,4))','javascript_456','',event,1.0);">map(function(x) { return x * x; },
    list(1,2,3,4))</pre>
      </div>

      <div class="normaltext">
        Now we can give a new definition of <span class="javascriptinline">scale_list</span> in terms of <span class="schemeinline">map</span>:
        <div style="position:absolute;display:none;" id="javascript_457_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction scale_list(items,factor) {\n   return map(function(x) { return x * factor; },\n              items);\n}\n\n// example\n\nscale_list(list(1,2,3,4,5),10)','javascript_457','',event,1.0);">function scale_list(items,factor) {
   return map(function(x) { return x * factor; },
              items);
}</pre>
      </div>

      <div class="normaltext">
        <span class="schemeinline">Map</span> is an important construct, not only because it captures a
        common pattern, but because it establishes a higher level of
        abstraction in dealing with lists.  In the original definition of <span class="javascriptinline">scale_list</span>, the recursive structure of the program draws attention to
        the element-by-element processing of the list.  Defining <span class="javascriptinline">scale_list</span> in terms of <span class="schemeinline">map</span> suppresses that level of detail and
        emphasizes that scaling transforms a list of elements to a list of
        results.  The difference between the two definitions is not that the
        computer is performing a different process (it isn&#146;t) but that we
        think about the process differently.  In effect, <span class="schemeinline">map</span> helps
        establish an abstraction barrier that isolates the implementation of
        functions
        that transform lists from the details of how the
        elements of the list are extracted and combined.  Like the barriers
        shown in figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#fig:abstraction-barriers">2.1</a>, this abstraction gives
        us the flexibility to change the low-level details of how sequences
        are implemented, while preserving the conceptual framework of
        operations that transform sequences to sequences.
        Section&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#sec:sequences-conventional-interfaces">2.2.3</a> expands on this use
        of sequences as a framework for organizing programs.
      </div>

      <div class="exercise">
<b>Exercise 2.22.</b><a name="ex:square-list"></a>
        The
        function
        <span class="javascriptinline">square_list</span> takes a list of
        numbers as argument and returns a list of the squares of those
        numbers.

        

        <div style="position:absolute;display:none;" id="javascript_459_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction square(x) { return x * x; }\n                \n// square_list to be given by student\n          \n// square_list to be given by student\nsquare_list(list(1,2,3,4))','javascript_459','',event,1.0);">// square_list to be given by student
square_list(list(1,2,3,4))</pre>

        Here are two different definitions of <span class="javascriptinline">square_list</span>.  Complete
        both of them by filling in the missing expressions:

        <form name="form_460" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_460.png"></form>
    <div style="position:absolute;display:none;" id="javascript_461_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.23.</b> 
        Louis Reasoner tries to rewrite the first <span class="javascriptinline">square_list</span>
        function
        of
        exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:square-list">2.22</a> so that it evolves an iterative
        process:

        <div style="position:absolute;display:none;" id="javascript_462_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction square(x) { return x * x; }\n                \nfunction square_list(items) {\n   function iter(things,answer) {\n      if (is_empty_list(things))\n         return answer;\n      else return iter(tail(things),\n                       pair(square(head(things)),\n                            answer));\n   }\n   return iter(items,[]);\n}\n\n// example\n\n// square_list to be given by student\nsquare_list(list(1,2,3,4))','javascript_462','',event,1.0);">function square_list(items) {
   function iter(things,answer) {
      if (is_empty_list(things))
         return answer;
      else return iter(tail(things),
                       pair(square(head(things)),
                            answer));
   }
   return iter(items,[]);
}</pre>

        Unfortunately, defining <span class="javascriptinline">square_list</span> this way produces the answer
        list in the reverse order of the one desired.  Why?

        Louis then tries to fix his bug by interchanging the arguments to
        <span class="javascriptinline">pair</span>:

        <div style="position:absolute;display:none;" id="javascript_463_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction square(x) { return x * x; }\n                \nfunction square_list(items) {\n   function iter(things,answer) {\n      if (is_empty_list(things))\n         return answer;\n      else return iter(tail(things),\n                       pair(answer,\n                            square(head(things))));\n   }\n   return iter(items,[]);\n}\n\n// example\n\n// square_list to be given by student\nsquare_list(list(1,2,3,4))','javascript_463','',event,1.0);">function square_list(items) {
   function iter(things,answer) {
      if (is_empty_list(things))
         return answer;
      else return iter(tail(things),
                       pair(answer,
                            square(head(things))));
   }
   return iter(items,[]);
}</pre>

        This doesn&#146;t work either.  Explain.
        <a name="ex:iter-square-list"></a>
    <div style="position:absolute;display:none;" id="javascript_464_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.24.</b>
        The
        function

        
        <span class="javascriptinline">for_each</span> is similar to <span class="schemeinline">map</span>.  It takes as
        arguments a
        function
        and a list of elements.  However, rather than
        forming a list of the  results, <span class="javascriptinline">for_each</span> just applies the
        function
        to each of the elements in turn, from left to right.  The values
        returned by applying the
        function
        to the elements are not used at
        all—<span class="javascriptinline">for_each</span> is used with
        functions
        that perform an action,
        such as printing.  For example,

        

        <div style="position:absolute;display:none;" id="javascript_466_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// for_each to be defined by the student\n          \nfor_each(function(x) { newline(); display(x); },\n         list(57,321,88));','javascript_466','',event,1.0);">for_each(function(x) { newline(); display(x); },
         list(57,321,88));</pre>

        The value returned by the call to <span class="javascriptinline">for_each</span> (not illustrated above)
        can be something arbitrary, such as true.  Give an
        implementation of <span class="javascriptinline">for_each</span>.
        <a name="ex:for-each"></a>
    <div style="position:absolute;display:none;" id="javascript_467_div"></div>
      </div>
      
      

    

    <h3><a name="subsection_2_2_2">2.2.2&nbsp;
        Hierarchical Structures
      </a></h3>
      

      <a name="sec:trees"></a>
      
      
      
      
      <div class="normaltext">
        The representation of sequences in terms of lists generalizes
        naturally to represent sequences whose elements may
        themselves be sequences.  For example, we can regard the object
        <span class="javascriptinline">[[1,[2,[]]],[3,[4,[]]]]</span> constructed by

        <div style="position:absolute;display:none;" id="javascript_468_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\npair(list(1,2),list(3,4))','javascript_468','',event,1.0);">pair(list(1,2),list(3,4))</pre>
        as a list of three items, the first of which is itself a list, <span class="javascriptinline">[1,[2,[]]]</span>. Figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:cons-of-2-lists">2.5</a> shows
        the representation of this structure in terms of pairs.

              <p><div align="center"><table width="100%">
<tr><td align="center">
<img src="img_original/ch2-Z-G-15.gif" border="0">
                <a name="fig:cons-of-2-lists"></a>
                
              </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  5</b>&nbsp;&nbsp;&nbsp;Structure formed by <span class="javascriptinline">pair(list(1,2),list(3,4))</span>.
                </div></caption>
<tr><td></td></tr>
</table></div></p>
      </div>

      <div class="normaltext">
        Another way to think of sequences whose elements are sequences is as
        <em>trees</em>.  The elements of the sequence are the branches of the
        tree, and elements that are themselves sequences are subtrees.
        Figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:list-as-tree-javascript">2.6</a> shows the structure in
        Figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:cons-of-2-lists">2.5</a> viewed as a tree.

        
              <p><div align="center"><table width="100%">
<tr><td align="center">
                <a name="fig:list-as-tree-javascript"></a>
                
                <P><img src="img_javascript/latex_49.png"></P>
              </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  6</b>&nbsp;&nbsp;&nbsp;The list structure in Figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:cons-of-2-lists">2.5</a> viewed as a tree.
                </div></caption>
<tr><td></td></tr>
</table></div></p>
          
      </div>

      <div class="normaltext">
        
        Recursion is a natural tool for dealing with tree structures, since
        we can often reduce operations on trees to operations on their
        branches, which reduce in turn to operations on the branches of the
        branches, and so on, until we reach the leaves of the tree.
        As an example, compare the <span class="javascriptinline">length</span>
        function
        of
        section&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#sec:sequences">2.2.1</a> with the 
        
        
        <span class="javascriptinline">count_leaves</span>
        function, which
        returns the total number of leaves of a tree:

        <div style="position:absolute;display:none;" id="javascript_469_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = [[1,[2,[]]],[3,[4,[]]]];','javascript_469','',event,1.0);">var x = [[1,[2,[]]],[3,[4,[]]]];</pre>

        <div style="position:absolute;display:none;" id="javascript_470_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = [[1,[2,[]]],[3,[4,[]]]];\n          \nfunction length(items) {\n   if (is_empty_list(items))\n      return 0;\n   else return 1 + length(tail(items));\n}\n          \nlength(x)','javascript_470','',event,1.0);">length(x)</pre>

        <div style="position:absolute;display:none;" id="javascript_471_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = [[1,[2,[]]],[3,[4,[]]]];\n          \nfunction count_leaves(x) {\n   if (is_empty_list(x)) \n      return 0;\n   else if (! is_pair(x))\n      return 1;\n   else return count_leaves(head(x)) +\n               count_leaves(tail(x));\n}\n          \ncount_leaves(x)','javascript_471','',event,1.0);">count_leaves(x)</pre>

        <div style="position:absolute;display:none;" id="javascript_472_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = [[1,[2,[]]],[3,[4,[]]]];\n          \nlist(x,x)','javascript_472','',event,1.0);">list(x,x)</pre>

        <div style="position:absolute;display:none;" id="javascript_473_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = [[1,[2,[]]],[3,[4,[]]]];\n          \nfunction length(items) {\n   if (is_empty_list(items))\n      return 0;\n   else return 1 + length(tail(items));\n}\n          \nlength(list(x,x))','javascript_473','',event,1.0);">length(list(x,x))</pre>

        <div style="position:absolute;display:none;" id="javascript_474_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = [[1,[2,[]]],[3,[4,[]]]];\n          \nfunction count_leaves(x) {\n   if (is_empty_list(x)) \n      return 0;\n   else if (! is_pair(x))\n      return 1;\n   else return count_leaves(head(x)) +\n               count_leaves(tail(x));\n}\n          \ncount_leaves(list(x,x))','javascript_474','',event,1.0);">count_leaves(list(x,x))</pre>
      </div>

      <div class="normaltext">
        To implement <span class="javascriptinline">count_leaves</span>, recall the recursive plan for computing
        <span class="javascriptinline">length</span>:

        <ul>
          <li> The <span class="javascriptinline">length</span> of a list <span class="javascriptinline">x</span> is 1 plus the <span class="javascriptinline">length</span> of the
            <span class="javascriptinline">tail</span> of <span class="javascriptinline">x</span>.
          </li>
          <li>
            The <span class="javascriptinline">length</span> of the empty list is 0.
          </li>
        </ul>
        The function <span class="javascriptinline">count_leaves</span> is similar.  The value for the empty list is the same:
        <ul>
          <li>
            <span class="javascriptinline">count_leaves</span> of the empty list is 0.
          </li>
        </ul>
        But in the reduction step, where we strip off the <span class="javascriptinline">head</span> of the
        list, we must take into account that the <span class="javascriptinline">head</span> may itself be a
        tree whose leaves we need to count.  Thus, the appropriate reduction
        step is
        <ul>
          <li>
            <span class="javascriptinline">count_leaves</span> of a tree <span class="javascriptinline">x</span> is <span class="javascriptinline">count_leaves</span> of the <span class="javascriptinline">head</span> of <span class="javascriptinline">x</span> plus <span class="javascriptinline">count_leaves</span> of the
            <span class="javascriptinline">tail</span> of <span class="javascriptinline">x</span>.
          </li>
        </ul>
        Finally, by taking <span class="javascriptinline">head</span>s we reach
        actual leaves, so we need another base case:
        <ul>
          <li>
            <span class="javascriptinline">count_leaves</span> of a leaf is 1.
          </li>
        </ul>
        To aid in writing recursive
        functions
        on trees, our JavaScript environment provides the primitive
        predicate 
        
        
        <span class="javascriptinline">is_pair</span>, which tests whether its argument is a pair.
        Here is the complete
        function:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_8"><a class="link" href="#footnote_8">8</a></a></span>

        <div style="position:absolute;display:none;" id="javascript_475_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction count_leaves(x) {\n   if (is_empty_list(x)) \n      return 0;\n   else if (! is_pair(x))\n      return 1;\n   else return count_leaves(head(x)) +\n               count_leaves(tail(x));\n}\n\n// example\n\ncount_leaves([[1,[2,[]]],[3,[4,[]]]])','javascript_475','',event,1.0);">function count_leaves(x) {
   if (is_empty_list(x)) 
      return 0;
   else if (! is_pair(x))
      return 1;
   else return count_leaves(head(x)) +
               count_leaves(tail(x));
}</pre>

        

      </div>

      <div class="exercise">
<b>Exercise 2.25.</b>
        Suppose we evaluate the expression 
        <span class="javascriptinline">list(1,list(2,list(3,4)))</span>.
        Give the result printed by the interpreter, the corresponding
        box-and-pointer structure, and the interpretation of this as a tree
        (as in figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:list-as-tree">2.</a>).
        <a name="ex:nested-list"></a>
    <div style="position:absolute;display:none;" id="javascript_477_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.26.</b> 
        Give combinations of <span class="javascriptinline">head</span>s and <span class="javascriptinline">tail</span>s that will pick 7 from
        each of the following lists:

        <form name="form_478" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_478.png"></form>
    <div style="position:absolute;display:none;" id="javascript_479_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.27.</b> 
        Suppose we define <span class="javascriptinline">x</span> and <span class="javascriptinline">y</span> to be two lists:

        <div style="position:absolute;display:none;" id="javascript_480_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = list(1,2,3);\n\nvar y = list(1,2,3);','javascript_480','',event,1.0);">var x = list(1,2,3);

var y = list(1,2,3);</pre>

        What result is printed by the interpreter in response to evaluating
        each of the following expressions:

        <div style="position:absolute;display:none;" id="javascript_481_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = list(1,2,3);\n\nvar y = list(1,2,3);\n        \nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n          \nappend(x,y)','javascript_481','',event,1.0);">append(x,y)</pre>


        <div style="position:absolute;display:none;" id="javascript_482_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = list(1,2,3);\n\nvar y = list(1,2,3);\n        \npair(x,y)','javascript_482','',event,1.0);">pair(x,y)</pre>

        <div style="position:absolute;display:none;" id="javascript_483_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = list(1,2,3);\n\nvar y = list(1,2,3);\n        \nlist(x,y)','javascript_483','',event,1.0);">list(x,y)</pre>

      </div>

      <div class="exercise">
<b>Exercise 2.28.</b>
        Modify your <span class="javascriptinline">reverse</span>
        function
        of exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:reverse">2.18</a> to
        produce a 
        
        
        <span class="javascriptinline">deep_reverse</span>
        function
        that takes a list as argument
        and returns as its value the list with its elements reversed and with
        all sublists deep-reversed as well.  For example, <span style="color:black" title="">consider</span>
        <div style="position:absolute;display:none;" id="javascript_484_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = list(list(1,2),list(3,4));','javascript_484','',event,1.0);">var x = list(list(1,2),list(3,4));</pre>
        <span style="color:black" title="">Here,</span>
        <div style="position:absolute;display:none;" id="javascript_485_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = list(list(1,2),list(3,4));\n        \nx','javascript_485','',event,1.0);">x</pre>

        <span style="color:black" title="">should return</span>

        <form name="form_486" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_486.png"></form>

        <div style="position:absolute;display:none;" id="javascript_487_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = list(list(1,2),list(3,4));\n        \n// reverse to be given by student\n          \nreverse(x)','javascript_487','',event,1.0);">reverse(x)</pre>
        <span style="color:black" title="">should return</span>
        <form name="form_488" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_488.png"></form>
        <span style="color:black" title="">whereas</span>
        
        <div style="position:absolute;display:none;" id="javascript_490_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = list(list(1,2),list(3,4));\n        \n// deep_reverse to be written by student; see Exercise 2.27\n          \ndeep_reverse(x)','javascript_490','',event,1.0);">deep_reverse(x)</pre>
        <span style="color:black" title="">should return</span>
        <form name="form_491" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_491.png"></form>
<div style="position:absolute;display:none;" id="javascript_492_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.29.</b>
        <a name="ex:fringe"></a>
        Write a
        function

        
        
        <span class="javascriptinline">fringe</span> that takes as argument a tree
        (represented as a list) and returns a list whose elements are all the
        leaves of the tree arranged in left-to-right order.  For example,
        <span style="color:black" title="">consider</span>

        

        <div style="position:absolute;display:none;" id="javascript_494_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = list(list(1,2),list(3,4))','javascript_494','',event,1.0);">var x = list(list(1,2),list(3,4))</pre>
        <span style="color:black" title="">Here,</span>
        <div style="position:absolute;display:none;" id="javascript_495_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// fringe to be written by student; see Exercise 2.28\n          \nfringe(x)','javascript_495','',event,1.0);">fringe(x)</pre>
        <span style="color:black" title="">should return</span>
        <form name="form_496" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_496.png"></form>
        and
        <div style="position:absolute;display:none;" id="javascript_497_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// fringe to be written by student; see Exercise 2.28\n          \nfringe(list(x,x))','javascript_497','',event,1.0);">fringe(list(x,x))</pre>
        should return
        <form name="form_498" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_498.png"></form>
<div style="position:absolute;display:none;" id="javascript_499_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.30.</b>
        
        A binary mobile consists of two branches, a left branch and a right
        branch.  Each branch is a rod of a certain length, from which hangs
        either a weight or another binary mobile.  We can represent a binary
        mobile using compound data by constructing it from two branches (for
        example, using <span class="schemeinline">list</span>):

        <div style="position:absolute;display:none;" id="javascript_500_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_mobile(left,right) {\n   return list(left,right);\n}','javascript_500','',event,1.0);">function make_mobile(left,right) {
   return list(left,right);
}</pre>

        A branch is constructed from a <span class="schemeinline">length</span> (which must be a number)
        together with a <span class="schemeinline">structure</span>, which may be either a number
        (representing a simple weight) or another mobile:

        <div style="position:absolute;display:none;" id="javascript_501_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_branch(length,structure) {\n   return list(length,structure);\n}','javascript_501','',event,1.0);">function make_branch(length,structure) {
   return list(length,structure);
}</pre>

        <ol class="exercise">
          <li>
            Write the corresponding selectors <span class="javascriptinline">left_branch</span> and
            <span class="javascriptinline">right_branch</span>, which return the branches of a mobile, and
                <span class="javascriptinline">branch_length</span> and <span class="javascriptinline">branch_structure</span>, which return 
            the components of a branch.
          </li>

          <li>
            Using your selectors, define a
            function
            <span class="javascriptinline">total_weight</span> 
            that returns the total weight of a mobile.
          </li>

          <li>
            A mobile is said to be 
            
            <em>balanced</em> if the torque applied
            by its top-left branch is equal to that applied by its top-right
            branch (that is, if the length of the left rod multiplied by the
            weight hanging from that rod is equal to the corresponding product for
            the right side) and if each of the submobiles hanging off its branches
            is balanced. Design a predicate that tests whether a binary mobile is
            balanced.
          </li>

          <li>
            Suppose we change the representation of mobiles so that the
            constructors are

            <div style="position:absolute;display:none;" id="javascript_502_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_mobile(left,right) {\n   return pair(left,right);\n}\nfunction make_branch(length,structure) {\n   return pair(length,structure);\n}','javascript_502','',event,1.0);">function make_mobile(left,right) {
   return pair(left,right);
}
function make_branch(length,structure) {
   return pair(length,structure);
}</pre>

            How much do you need to change your programs to convert to the new
            representation?
          </li>
        </ol>
        <a name="ex:mobile"></a>
    <div style="position:absolute;display:none;" id="javascript_503_div"></div>
    
      </div>
      
      
      
      

      <H4>Mapping over trees</H4>
        
      

      
      

      <div class="normaltext">
        Just as <span class="javascriptinline">map</span> is a powerful abstraction for dealing with sequences,
        <span class="javascriptinline">map</span> together with recursion is a powerful abstraction for
        dealing with trees.  For instance, the <span class="javascriptinline">scale_tree</span>
        function, analogous to <span class="javascriptinline">scale_list</span> of
        section&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#sec:sequences">2.2.1</a>, takes as arguments a numeric factor and a
        tree whose leaves are numbers.  It returns a tree of the same shape,
        where each number is multiplied by the factor.
        The recursive plan for <span class="javascriptinline">scale_tree</span> is similar to the one for
        <span class="javascriptinline">count_leaves</span>:

        <div style="position:absolute;display:none;" id="javascript_505_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction scale_tree(tree,factor) {\n   if (is_empty_list(tree))\n      return [];\n   else if (! is_pair(tree))\n      return tree * factor;\n   else return pair(scale_tree(head(tree),factor),\n                    scale_tree(tail(tree),factor));\n}\n\n// example\n\nscale_tree(list(1,list(2,list(3,4),5),list(6,7)),\n           10)','javascript_505','',event,1.0);">function scale_tree(tree,factor) {
   if (is_empty_list(tree))
      return [];
   else if (! is_pair(tree))
      return tree * factor;
   else return pair(scale_tree(head(tree),factor),
                    scale_tree(tail(tree),factor));
}</pre>

        <div style="position:absolute;display:none;" id="javascript_506_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction scale_tree(tree,factor) {\n   if (is_empty_list(tree))\n      return [];\n   else if (! is_pair(tree))\n      return tree * factor;\n   else return pair(scale_tree(head(tree),factor),\n                    scale_tree(tail(tree),factor));\n}\n        \nscale_tree(list(1,list(2,list(3,4),5),list(6,7)),\n           10)','javascript_506','',event,1.0);">scale_tree(list(1,list(2,list(3,4),5),list(6,7)),
           10)</pre>
      </div>

      <div class="normaltext">
        Another way to implement <span class="javascriptinline">scale_tree</span> is to regard the
        tree as a sequence of sub-trees and use <span class="javascriptinline">map</span>.  We map
        over the sequence, scaling each sub-tree in turn, and return the list
        of results.  In the base case, where the tree is a leaf, we simply
        multiply by the factor:

        <div style="position:absolute;display:none;" id="javascript_507_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction scale_tree(tree,factor) {\n   return map(function(sub_tree) {\n                 if (is_pair(sub_tree))\n                    return scale_tree(sub_tree,factor);\n                 else \n                    return sub_tree * factor;\n              },\n              tree);\n}\n\n// example\n\nscale_tree(list(1,list(2,list(3,4),5),list(6,7)),\n           10)','javascript_507','',event,1.0);">function scale_tree(tree,factor) {
   return map(function(sub_tree) {
                 if (is_pair(sub_tree))
                    return scale_tree(sub_tree,factor);
                 else 
                    return sub_tree * factor;
              },
              tree);
}</pre>
      </div>

      <div class="normaltext">
        Many tree operations can be implemented by similar combinations of
        sequence operations and recursion.
      </div>

      <div class="exercise">
<b>Exercise 2.31.</b>
        Define a
        function
        <span class="javascriptinline">square_tree</span> analogous to the <span class="javascriptinline">square_list</span>
        function
        of exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:square-list">2.22</a>.  That is, <span class="javascriptinline">square_tree</span> should behave as follows:

        

        <div style="position:absolute;display:none;" id="javascript_509_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// square_tree to be written by student; see Exercise 2.30\n          \nsquare_tree(list(1,\n                 list(2,list(3,4),5),\n                 list(6,7)))','javascript_509','',event,1.0);">square_tree(list(1,
                 list(2,list(3,4),5),
                 list(6,7)))</pre>
        <span style="color:black" title="">
          should return
        <form name="form_510" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_510.png"></form>
        </span>
        Define <span class="javascriptinline">square_tree</span> both directly (i.e., without using any
        higher-order
        functions) and also by using <span class="javascriptinline">map</span> and recursion.
        <a name="ex:square-tree"></a>
    <div style="position:absolute;display:none;" id="javascript_511_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.32.</b><a name="ex:tree-map"></a>
        Abstract your answer to exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:square-tree">2.31</a> to produce a
        function

        
        <span class="javascriptinline">tree_map</span> with the property that <span class="javascriptinline">square_tree</span>
        could be defined as

        

        <div style="position:absolute;display:none;" id="javascript_513_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// square_tree to be written by student; see Exercise 2.30\n          \n// tree_map to be written by student; see Exercise 2.31\n          \nfunction square_tree(tree) {\n   return tree_map(square,tree);\n}','javascript_513','',event,1.0);">function square_tree(tree) {
   return tree_map(square,tree);
}</pre>
    <div style="position:absolute;display:none;" id="javascript_514_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.33.</b>
        We can represent a 
        
        set as a list of distinct elements, and we can
        represent the set of all subsets of the set as a list of lists.  For
        example, if the set is <span class="javascriptinline">[1,[2,[3,[]]]]</span>, then the set of all subsets is
        <span class="javascriptinline">[[],[[3,[]],[[2,[]],[[2,[3,[]]],[[1,[]],[[2,[3,[]]],[[1,[2,[]]],[[1,[2,[3,[]]]],[]]]]]]]]]</span>.  Complete the
        following definition of a
        function
        that generates the set of subsets
        of a set and give a clear explanation of why it works:
        <div style="position:absolute;display:none;" id="javascript_515_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n          \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction subsets(s) {\n   if (is_empty_list(s))\n      return list([]);\n   else {\n      var rest = subsets(tail(s));\n      return append(rest,map(^??^,rest));\n   }\n}','javascript_515','',event,1.0);">function subsets(s) {
   if (is_empty_list(s))
      return list([]);
   else {
      var rest = subsets(tail(s));
      return append(rest,map(^??^,rest));
   }
}</pre>
    <div style="position:absolute;display:none;" id="javascript_516_div"></div>
    
      </div>
      
      

    

    <h3><a name="subsection_2_2_3">2.2.3&nbsp;
        Sequences as Conventional Interfaces
      </a></h3>
      

      <a name="sec:sequences-conventional-interfaces"></a>
      
      

      <div class="normaltext">
        In working with compound data, we&#146;ve stressed how data abstraction
        permits us to design programs without becoming enmeshed in the details
        of data representations, and how abstraction preserves for us the
        flexibility to experiment with alternative representations.  In this
        section, we introduce another powerful design principle for working
        with data structures—the use of <em>conventional interfaces</em>.
      </div>

      <div class="normaltext">
        In section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')">1.3</a> we saw how program
        abstractions, implemented as higher-order
        functions, can capture
        common patterns in programs that deal with numerical data.  Our
        ability to formulate analogous operations for working with compound
        data depends crucially on the style in which we manipulate our data
        structures.  Consider, for example, the following
        function, analogous
        to the <span class="javascriptinline">count_leaves</span>
        function
        of section&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#sec:trees">2.2.2</a>, which
        takes a tree as argument and computes the sum of the squares of the
        leaves that are odd:

        

        <div style="position:absolute;display:none;" id="javascript_519_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction square(x) { return x * x; }\n                \nfunction is_odd(n) {\n   return n % 2 === 1;\n}\n          \nfunction sum_odd_squares(tree) {\n   if (is_empty_list(tree))\n      return 0;\n   else if (! is_pair(tree))\n      return (is_odd(tree)) ? square(tree) : 0;\n   else return sum_odd_squares(head(tree))\n               +\n               sum_odd_squares(tail(tree));\n}\n\n// example\n\nsum_odd_squares(list(list(2,3),list(4,5)))','javascript_519','',event,1.0);">function sum_odd_squares(tree) {
   if (is_empty_list(tree))
      return 0;
   else if (! is_pair(tree))
      return (is_odd(tree)) ? square(tree) : 0;
   else return sum_odd_squares(head(tree))
               +
               sum_odd_squares(tail(tree));
}</pre>

        
      </div>

      <div class="normaltext">
        On the surface, this
        function
        is very different from the following
        one, which constructs a list of all the even Fibonacci numbers
        <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_698.png"></span>, where <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_699.png"></span> is less than or equal to a given integer <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_700.png"></span>:
        <div style="position:absolute;display:none;" id="javascript_521_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction is_even(n) {\n   return n % 2 === 0;\n}\n          \nfunction fib(n) {\n   if (n === 0) \n        return 0;\n   else if (n === 1)\n        return 1;\n   else return fib(n - 1) + fib(n - 2);\n}\n          \nfunction even_fibs(n) {\n   function next(k) {\n      if (k &gt; n) \n         return [];\n      else {\n         var f = fib(k);\n         if (is_even(f)) \n            return pair(f,next(k+1));\n         else return next(k+1);\n      }\n   }\n   return next(0);\n}\n\n// example\n\neven_fibs(9)','javascript_521','',event,1.0);">function even_fibs(n) {
   function next(k) {
      if (k &gt; n) 
         return [];
      else {
         var f = fib(k);
         if (is_even(f)) 
            return pair(f,next(k+1));
         else return next(k+1);
      }
   }
   return next(0);
}</pre>

        

      </div>

      <div class="normaltext">
        Despite the fact that these two
        functions
        are structurally very
        different, a more abstract description of the two computations reveals
        a great deal of similarity.  The first program
        <ul>
          <li>enumerates the leaves of a tree;
          </li>
          <li>filters them, selecting the odd ones;
          </li>
          <li>squares each of the selected ones; and
          </li>
          <li>accumulates the results using <span class="javascriptinline">+</span>, starting with 0.
          </li>
        </ul>
      </div>

      <div class="normaltext">
        The second program
        <ul>
          <li>enumerates the integers from 0 to <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_701.png"></span>;
          </li>
          <li>computes the Fibonacci number for each integer;
          </li>
          <li>filters them, selecting the even ones; and
          </li>
          <li>accumulates the results using <span class="javascriptinline">pair</span>,  starting with the
            empty list.
          </li>
        </ul>
      </div>

      <div class="normaltext">
        
        
        A signal-processing engineer would find it natural to conceptualize
        these processes in terms of signals flowing through a cascade of
        stages, each of which implements part of the program plan, as shown in
        figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:signal-flow-plans">2.7</a>.  In <span class="javascriptinline">sum_odd_squares</span>, we
        begin with an 
        
        <em>enumerator</em>, which generates a &#147;signal&#148;
        consisting of the leaves of a given tree.  This signal is passed
        through a 
        
        <em>filter</em>, which eliminates all but the odd elements.
        The resulting signal is in turn passed through a 
        
        <em>map</em>, which is a
        &#147;transducer&#148; that applies the <span class="schemeinline">square</span>
        function
        to each
        element.  The output of the map is then fed to an 
        
        <em>accumulator</em>,
        which combines the elements using <span class="javascriptinline">+</span>, starting from an initial 0.
        The plan for <span class="javascriptinline">even_fibs</span> is analogous.


              <p><div align="center"><table width="100%">
<tr><td align="center">
<img src="img_original/ch2-Z-G-17.gif" border="0">
                <a name="fig:signal-flow-plans"></a>
                
              </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  7</b>&nbsp;&nbsp;&nbsp;The signal-flow plans for the
        functions
        <span class="javascriptinline">sum_odd_squares</span> (top) and <span class="javascriptinline">even_fibs</span> (bottom) reveal the
        commonality between the two programs.
                </div></caption>
<tr><td></td></tr>
</table></div></p>
      </div>

      <div class="normaltext">
        Unfortunately, the two
        function
        definitions above fail to exhibit this
        signal-flow structure.  For instance, if we examine the <span class="javascriptinline">sum_odd_squares</span>
        function, we find that the enumeration is
        implemented partly by the <span class="javascriptinline">is_empty_list</span> and <span class="javascriptinline">is_pair</span> tests and partly
        by the tree-recursive structure of the
        function.  Similarly, the
        accumulation is found partly in the tests and partly in the addition used
        in the recursion.  In general, there are no distinct parts of either
        function
        that correspond to the elements in the signal-flow
        description.
        Our two
        functions
        decompose the computations in a different way,
        spreading the enumeration over the program and mingling it with the
        map, the filter, and the accumulation.  If we could organize our
        programs to make the signal-flow structure manifest in the
        functions
        we write, this would increase the conceptual clarity of the resulting
        code.
      </div>

      <H4>Sequence Operations</H4>
        
      

      <a name="sec:sequence-operations"></a>
      

      <div class="normaltext">
        The key to organizing programs so as to more clearly reflect the
        signal-flow structure is to concentrate on the &#147;signals&#148; that flow
        from one stage in the process to the next.  If we represent these
        signals as lists, then we can use list operations to implement the
        processing at each of the stages.  For instance, we can implement the
        mapping stages of the signal-flow diagrams using the <span class="javascriptinline">map</span>
        function
        from section&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#sec:sequences">2.2.1</a>:
        <div style="position:absolute;display:none;" id="javascript_523_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction square(x) { return x * x; }\n                \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nmap(square,list(1,2,3,4,5))','javascript_523','',event,1.0);">map(square,list(1,2,3,4,5))</pre>
      </div>

      <div class="normaltext">
        Filtering a sequence to select only those elements that satisfy a
        given predicate is accomplished by
        <div style="position:absolute;display:none;" id="javascript_524_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction filter(predicate,sequence) {\n   if (is_empty_list(sequence))\n      return [];\n   else if (predicate(head(sequence))) \n      return pair(head(sequence),\n                  filter(predicate,tail(sequence)));\n   else \n      return filter(predicate,tail(sequence));\n}\n\n// example\n\nfunction is_odd(n) {\n   return n % 2 === 1;\n}\n\nfilter(is_odd,list(1,2,3,4,5))','javascript_524','',event,1.0);">function filter(predicate,sequence) {
   if (is_empty_list(sequence))
      return [];
   else if (predicate(head(sequence))) 
      return pair(head(sequence),
                  filter(predicate,tail(sequence)));
   else 
      return filter(predicate,tail(sequence));
}</pre>

        

      </div>

      <div class="normaltext">
        For example,
        <div style="position:absolute;display:none;" id="javascript_526_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction filter(predicate,sequence) {\n   if (is_empty_list(sequence))\n      return [];\n   else if (predicate(head(sequence))) \n      return pair(head(sequence),\n                  filter(predicate,tail(sequence)));\n   else \n      return filter(predicate,tail(sequence));\n}\n        \nfunction is_odd(n) {\n   return n % 2 === 1;\n}\n          \nfilter(is_odd,list(1,2,3,4,5))','javascript_526','',event,1.0);">filter(is_odd,list(1,2,3,4,5))</pre>


        Accumulations can be implemented by
        
        <div style="position:absolute;display:none;" id="javascript_527_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}','javascript_527','',event,1.0);">function accumulate(op,initial,sequence) {
   if (is_empty_list(sequence))
      return initial;
   else 
      return op(head(sequence),
                accumulate(op,initial,tail(sequence)));
}</pre>

        

        <div style="position:absolute;display:none;" id="javascript_529_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction plus(x,y) {\n   return x + y;\n}\n          \naccumulate(plus,0,list(1,2,3,4,5))','javascript_529','',event,1.0);">accumulate(plus,0,list(1,2,3,4,5))</pre>

        


        <div style="position:absolute;display:none;" id="javascript_531_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction times(x,y) {\n   return x * y;\n}\n          \naccumulate(times,1,list(1,2,3,4,5))','javascript_531','',event,1.0);">accumulate(times,1,list(1,2,3,4,5))</pre>

        <div style="position:absolute;display:none;" id="javascript_532_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \naccumulate(pair,[],list(1,2,3,4,5))','javascript_532','',event,1.0);">accumulate(pair,[],list(1,2,3,4,5))</pre>
      </div>

      <div class="normaltext">
        All that remains to implement signal-flow diagrams is to enumerate the
        sequence of elements to be processed.  For <span class="javascriptinline">even_fibs</span>, we need to
        generate the sequence of
        integers in a given range, which we can do as follows:
        <div style="position:absolute;display:none;" id="javascript_533_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction enumerate_interval(low,high) {\n   if (low &gt; high)\n      return [];\n   else \n      return pair(low,\n                  enumerate_interval(low+1,high));\n}','javascript_533','',event,1.0);">function enumerate_interval(low,high) {
   if (low &gt; high)
      return [];
   else 
      return pair(low,
                  enumerate_interval(low+1,high));
}</pre>

        <div style="position:absolute;display:none;" id="javascript_534_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction enumerate_interval(low,high) {\n   if (low &gt; high)\n      return [];\n   else \n      return pair(low,\n                  enumerate_interval(low+1,high));\n}\n          \nenumerate_interval(2,7)','javascript_534','',event,1.0);">enumerate_interval(2,7)</pre>
      </div>

      <div class="normaltext">
        To enumerate the leaves of a tree, we can use<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_9"><a class="link" href="#footnote_9">9</a></a></span>

            

        <div style="position:absolute;display:none;" id="javascript_535_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n          \nfunction enumerate_tree(tree) {\n   if (is_empty_list(tree)) \n      return [];\n   else if (! is_pair(tree))\n      return list(tree);\n   else \n      return append(enumerate_tree(head(tree)),\n                    enumerate_tree(tail(tree)));\n}','javascript_535','',event,1.0);">function enumerate_tree(tree) {
   if (is_empty_list(tree)) 
      return [];
   else if (! is_pair(tree))
      return list(tree);
   else 
      return append(enumerate_tree(head(tree)),
                    enumerate_tree(tail(tree)));
}</pre>

        <div style="position:absolute;display:none;" id="javascript_536_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n          \nfunction enumerate_tree(tree) {\n   if (is_empty_list(tree)) \n      return [];\n   else if (! is_pair(tree))\n      return list(tree);\n   else \n      return append(enumerate_tree(head(tree)),\n                    enumerate_tree(tail(tree)));\n}\n        \nenumerate_tree(list(1,list(2,list(3,4)),5))','javascript_536','',event,1.0);">enumerate_tree(list(1,list(2,list(3,4)),5))</pre>
      </div>

      <div class="normaltext">
        Now we can reformulate <span class="javascriptinline">sum_odd_squares</span> and <span class="javascriptinline">even_fibs</span> as in
        the signal-flow diagrams.  For <span class="javascriptinline">sum_odd_squares</span>, we enumerate the
        sequence of leaves of the tree, filter this to keep only the odd
        numbers in the sequence, square each element, and sum the results:
        <div style="position:absolute;display:none;" id="javascript_537_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction square(x) { return x * x; }\n                \nfunction plus(x,y) {\n   return x + y;\n}\n          \nfunction filter(predicate,sequence) {\n   if (is_empty_list(sequence))\n      return [];\n   else if (predicate(head(sequence))) \n      return pair(head(sequence),\n                  filter(predicate,tail(sequence)));\n   else \n      return filter(predicate,tail(sequence));\n}\n        \nfunction is_odd(n) {\n   return n % 2 === 1;\n}\n          \nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n          \nfunction enumerate_tree(tree) {\n   if (is_empty_list(tree)) \n      return [];\n   else if (! is_pair(tree))\n      return list(tree);\n   else \n      return append(enumerate_tree(head(tree)),\n                    enumerate_tree(tail(tree)));\n}\n        \nfunction sum_odd_squares(tree) {\n   return accumulate(plus,\n                     0,\n                     map(square,\n                         filter(is_odd,\n                                enumerate_tree(tree))));\n}\n\n// example\n\nsum_odd_squares(list(list(2,3),list(4,5)))','javascript_537','',event,1.0);">function sum_odd_squares(tree) {
   return accumulate(plus,
                     0,
                     map(square,
                         filter(is_odd,
                                enumerate_tree(tree))));
}</pre>
      </div>

      <div class="normaltext">
        For <span class="javascriptinline">even_fibs</span>, we enumerate the integers from 0 to <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_702.png"></span>, generate
        the Fibonacci number for each of these integers, filter the resulting
        sequence to keep only the even elements, and accumulate the results
        into a list:
        <div style="position:absolute;display:none;" id="javascript_538_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction is_even(n) {\n   return n % 2 === 0;\n}\n          \nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction filter(predicate,sequence) {\n   if (is_empty_list(sequence))\n      return [];\n   else if (predicate(head(sequence))) \n      return pair(head(sequence),\n                  filter(predicate,tail(sequence)));\n   else \n      return filter(predicate,tail(sequence));\n}\n        \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction fib(n) {\n   if (n === 0) \n        return 0;\n   else if (n === 1)\n        return 1;\n   else return fib(n - 1) + fib(n - 2);\n}\n          \nfunction enumerate_interval(low,high) {\n   if (low &gt; high)\n      return [];\n   else \n      return pair(low,\n                  enumerate_interval(low+1,high));\n}\n          \nfunction even_fibs(n) {\n   return accumulate(pair,\n                     [],\n                     filter(is_even,\n                            map(fib,\n                                enumerate_interval(0,n))));\n}\n\n// example\n\neven_fibs(9)','javascript_538','',event,1.0);">function even_fibs(n) {
   return accumulate(pair,
                     [],
                     filter(is_even,
                            map(fib,
                                enumerate_interval(0,n))));
}</pre>
      </div>

      <div class="normaltext">
        The value of expressing programs as sequence operations is that this
        helps us make program designs that are modular, that is, designs that
        are constructed by combining relatively independent pieces.  We can
        encourage modular design by providing a library of standard components
        together with a conventional interface for connecting the components
        in flexible ways.
      </div>

      <div class="normaltext">
        
        
        Modular construction is a powerful strategy for
        controlling complexity in engineering design.  In real
        signal-processing applications, for example, designers regularly build
        systems by cascading elements selected from standardized families of
        filters and transducers.  Similarly, sequence operations provide a
        library of standard program elements that we can mix and match.  For
        instance, we can reuse pieces from the <span class="javascriptinline">sum_odd_squares</span> and <span class="schemeinline">even-fibs</span>
        functions
        in a program that constructs a list of the
        squares of the first <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_703.png"></span> Fibonacci numbers:
        <div style="position:absolute;display:none;" id="javascript_539_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction square(x) { return x * x; }\n                \nfunction fib(n) {\n   if (n === 0) \n        return 0;\n   else if (n === 1)\n        return 1;\n   else return fib(n - 1) + fib(n - 2);\n}\n          \nfunction enumerate_interval(low,high) {\n   if (low &gt; high)\n      return [];\n   else \n      return pair(low,\n                  enumerate_interval(low+1,high));\n}\n          \nfunction list_fib_squares(n) {\n   return accumulate(pair,\n                     [],\n                     map(square,\n                         map(fib,\n                             enumerate_interval(0,n))));\n}                         \n\n// example\n\nlist_fib_squares(10)','javascript_539','',event,1.0);">function list_fib_squares(n) {
   return accumulate(pair,
                     [],
                     map(square,
                         map(fib,
                             enumerate_interval(0,n))));
}                         </pre>

        <div style="position:absolute;display:none;" id="javascript_540_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction square(x) { return x * x; }\n                \nfunction fib(n) {\n   if (n === 0) \n        return 0;\n   else if (n === 1)\n        return 1;\n   else return fib(n - 1) + fib(n - 2);\n}\n          \nfunction enumerate_interval(low,high) {\n   if (low &gt; high)\n      return [];\n   else \n      return pair(low,\n                  enumerate_interval(low+1,high));\n}\n          \nfunction list_fib_squares(n) {\n   return accumulate(pair,\n                     [],\n                     map(square,\n                         map(fib,\n                             enumerate_interval(0,n))));\n}                         \n        \nlist_fib_squares(10)','javascript_540','',event,1.0);">list_fib_squares(10)</pre>
      </div>

      <div class="normaltext">
        We can rearrange the pieces and use them in computing the product of
        the odd integers in a sequence:
        <div style="position:absolute;display:none;" id="javascript_541_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction square(x) { return x * x; }\n                \nfunction filter(predicate,sequence) {\n   if (is_empty_list(sequence))\n      return [];\n   else if (predicate(head(sequence))) \n      return pair(head(sequence),\n                  filter(predicate,tail(sequence)));\n   else \n      return filter(predicate,tail(sequence));\n}\n        \nfunction is_odd(n) {\n   return n % 2 === 1;\n}\n          \nfunction times(x,y) {\n   return x * y;\n}\n          \nfunction product_of_squares_of_odd_elements(sequence) {\n   return accumulate(times,\n                     1,\n                     map(square,\n                         filter(is_odd,sequence)));\n}\n\n// example\n\nproduct_of_squares_of_odd_elements(list(1,2,3,4,5))','javascript_541','',event,1.0);">function product_of_squares_of_odd_elements(sequence) {
   return accumulate(times,
                     1,
                     map(square,
                         filter(is_odd,sequence)));
}</pre>

        <div style="position:absolute;display:none;" id="javascript_542_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction square(x) { return x * x; }\n                \nfunction filter(predicate,sequence) {\n   if (is_empty_list(sequence))\n      return [];\n   else if (predicate(head(sequence))) \n      return pair(head(sequence),\n                  filter(predicate,tail(sequence)));\n   else \n      return filter(predicate,tail(sequence));\n}\n        \nfunction is_odd(n) {\n   return n % 2 === 1;\n}\n          \nfunction times(x,y) {\n   return x * y;\n}\n          \nfunction product_of_squares_of_odd_elements(sequence) {\n   return accumulate(times,\n                     1,\n                     map(square,\n                         filter(is_odd,sequence)));\n}\n        \nproduct_of_squares_of_odd_elements(list(1,2,3,4,5))','javascript_542','',event,1.0);">product_of_squares_of_odd_elements(list(1,2,3,4,5))</pre>
      </div>

      <div class="normaltext">
        We can also formulate conventional data-processing applications in
        terms of sequence operations.  Suppose we have a sequence of personnel
        records and we want to find the salary of the highest-paid programmer.
        Assume that we have a selector <span class="javascriptinline">salary</span> that returns the salary of
        a record, and a predicate <span class="javascriptinline">is_programmer</span> that tests if a record is
        for a programmer.  Then we can write
        <form name="form_543" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_543.png"></form>
      </div>

      <div class="normaltext">
        These examples give just a hint of the vast range of operations that
        can be expressed as sequence operations.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_10"><a class="link" href="#footnote_10">10</a></a></span>
      </div>

      <div class="normaltext">
        Sequences, implemented here as lists, serve
        as a conventional interface that permits us to combine processing
        modules.  Additionally, when we uniformly represent structures as
        sequences, we have localized the data-structure dependencies in our
        programs to a small number of sequence operations.  By changing these,
        we can experiment with alternative representations of sequences, while
        leaving the overall design of our programs intact.  We will exploit
        this capability in section&nbsp;, when we generalize the
        sequence-processing paradigm to admit infinite sequences.
      </div>

      <div class="exercise">
<b>Exercise 2.34.</b>
        Fill in the missing expressions to complete the following definitions
        of some basic list-manipulation operations as accumulations:
        <div style="position:absolute;display:none;" id="javascript_544_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction map(p,sequence) {\n   return accumulate(function(x,y) { ?? }, \n                     [], sequence);\n}\n\nfunction append(seq1,seq2) {\n   return accumulate(pair, ??, ??);\n}\n\nfunction length(sequence) {\n   return accumulate(??, 0, sequence);\n}','javascript_544','',event,1.0);">function map(p,sequence) {
   return accumulate(function(x,y) { ?? }, 
                     [], sequence);
}

function append(seq1,seq2) {
   return accumulate(pair, ??, ??);
}

function length(sequence) {
   return accumulate(??, 0, sequence);
}</pre>
    <div style="position:absolute;display:none;" id="javascript_545_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.35.</b><a name="ex:horner"></a>
        
        Evaluating a polynomial in <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_704.png"></span> at a given value of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_705.png"></span> can be
        formulated as an accumulation.  We evaluate the polynomial
        <P><img src="img_javascript/latex_50.png"></P>
        using a well-known algorithm called 
        
        <em>Horner&#146;s rule</em>, which
        structures the computation as
        <P><img src="img_javascript/latex_51.png"></P>
        In other words, we start with <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_706.png"></span>, multiply by <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_707.png"></span>, add <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_708.png"></span>,
        multiply by <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_709.png"></span>, and so on, until we reach <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_710.png"></span>.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_11"><a class="link" href="#footnote_11">11</a></a></span>

        Fill in the following template to produce a
        function
        that evaluates a
        polynomial using Horner&#146;s rule.
        Assume that the coefficients of the
        polynomial are arranged in a sequence, from <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_713.png"></span> through <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_714.png"></span>.
        <div style="position:absolute;display:none;" id="javascript_546_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction horner_eval(x,coefficient_sequence) {\n   return accumulate(function(this_coeff,\n                              higher_terms) { \n                        ?? \n                     },\n                     0,\n                     coefficient_sequence);\n}','javascript_546','',event,1.0);">function horner_eval(x,coefficient_sequence) {
   return accumulate(function(this_coeff,
                              higher_terms) { 
                        ?? 
                     },
                     0,
                     coefficient_sequence);
}</pre>

        For example, to compute <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_715.png"></span> at <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_716.png"></span> you would evaluate
        <div style="position:absolute;display:none;" id="javascript_547_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction horner_eval(x,coefficient_sequence) {\n   return accumulate(function(this_coeff,\n                              higher_terms) { \n                        ?? \n                     },\n                     0,\n                     coefficient_sequence);\n}\n        \nhorner_eval(2,list(1,3,0,5,0,1))','javascript_547','',event,1.0);">horner_eval(2,list(1,3,0,5,0,1))</pre>
    <div style="position:absolute;display:none;" id="javascript_548_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.36.</b><a name="ex:countleaves-as-accumulation"></a>
        Redefine <span class="javascriptinline">count_leaves</span> from section&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#sec:trees">2.2.2</a> as an
        accumulation:
        <div style="position:absolute;display:none;" id="javascript_549_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction count_leaves(t) {\n   return accumulate(??, ??, map(??, ??));\n}','javascript_549','',event,1.0);">function count_leaves(t) {
   return accumulate(??, ??, map(??, ??));
}</pre>
    <div style="position:absolute;display:none;" id="javascript_550_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.37.</b><a name="ex:accumulate-n"></a>
        The
        function
        <span class="javascriptinline">accumulate_n</span> is similar to <span class="javascriptinline">accumulate</span> except
        that it takes as its third argument a sequence of sequences, which are all
        assumed to have the same number of elements.  It applies the
        designated accumulation
        function
        to combine all the first elements of
        the sequences, all the second elements of the sequences, and so on, and
        returns a sequence of the results.  For instance, if <span class="schemeinline">s</span> is a sequence
         containing four sequences, <span class="javascriptinline">[[1,[2,[3,[]]]],[[4,[5,[6,[]]]],[[7,[8,[9,[]]]],[[10,[11,[12,[]]]],[]]]]]</span>
        then the value of <span class="javascriptinline">accumulate_n(plus,0,s)</span> should be the sequence <span class="javascriptinline">[22,[26,[30,[]]]]</span>.  Fill in the missing expressions
        in the following definition of <span class="javascriptinline">accumulate_n</span>:
        <div style="position:absolute;display:none;" id="javascript_551_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate_n(op,init,seqs) {\n   if (is_empty_list(head(seqs)))\n      return [];\n   else \n      return pair(accumulate(op,init,??),\n                  accumulate_n(op,init,??));\n}','javascript_551','',event,1.0);">function accumulate_n(op,init,seqs) {
   if (is_empty_list(head(seqs)))
      return [];
   else 
      return pair(accumulate(op,init,??),
                  accumulate_n(op,init,??));
}</pre>
    <div style="position:absolute;display:none;" id="javascript_552_div"></div>
    
    </div>

      <div class="exercise">
<b>Exercise 2.38.</b><a name="ex:matrix-ops"></a>
        
        
        
        Suppose we represent vectors <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_717.png"></span> as sequences of numbers, and
        matrices <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_718.png"></span> as sequences of vectors (the rows of the matrix).
        For example, the matrix
        <P><img src="img_javascript/latex_52.png"></P>
        is represented as the sequence <span class="javascriptinline">[[1,[2,[3,[4,[]]]]],[[4,[5,[6,[6,[]]]]],[[6,[7,[8,[9,[]]]]],[]]]]</span>.
        With this representation, we can use sequence operations to concisely
        express the basic matrix and vector operations.  These operations
        (which are described in any book on matrix algebra) are the following:


        <ul>
          <li>
          <span class="javascriptinline">dot_product(</span><span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_720.png"></span><span class="javascriptinline">,</span><span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_721.png"></span><span class="javascriptinline">)</span> returns the sum <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_722.png"></span>.
          </li>
          <li>
            <span class="javascriptinline">matrix_times_vector(</span><span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_725.png"></span><span class="javascriptinline">,</span><span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_726.png"></span><span class="javascriptinline">)</span> returns the vector <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_727.png"></span>, where <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_728.png"></span>.
          </li>
          <li>
            <span class="javascriptinline">matrix_times_matrix(</span><span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_730.png"></span><span class="javascriptinline">,</span><span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_731.png"></span><span class="javascriptinline">)</span> returns the matrix <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_732.png"></span>, where <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_733.png"></span>.
          </li>
          <li>
            <span class="javascriptinline">transpose(</span><span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_735.png"></span><span class="javascriptinline">)</span> returns the matrix <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_736.png"></span>, where <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_737.png"></span>.
          </li>
        </ul>
        We can define the dot product as<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_12"><a class="link" href="#footnote_12">12</a></a></span>
        <div style="position:absolute;display:none;" id="javascript_554_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction plus(x,y) {\n   return x + y;\n}\n          \nfunction times(x,y) {\n   return x * y;\n}\n          \nfunction dot_product(v,w) {\n   return accumulate(plus,0,map(times,v,w));\n}\n\n// example\n\ndot_product(list(1,2),list(3,4))','javascript_554','',event,1.0);">function dot_product(v,w) {
   return accumulate(plus,0,map(times,v,w));
}</pre>
        

        Fill in the missing expressions in the following
        functions
        for
        computing the other matrix operations.  (The
        function
        <span class="javascriptinline">accumulate_n</span> is
        defined in exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:accumulate-n">2.37</a>.)
        <div style="position:absolute;display:none;" id="javascript_556_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction matrix_times_vector(m,v) {\n   return map(??,m);\n}\n\nfunction transpose(mat) {\n   return accumulate_n(??,??,mat);\n}\n\nfunction matrix_times_matrix(n,m) {\n   var cols = transpose(n);\n   return map(??,m);\n}','javascript_556','',event,1.0);">function matrix_times_vector(m,v) {
   return map(??,m);
}

function transpose(mat) {
   return accumulate_n(??,??,mat);
}

function matrix_times_matrix(n,m) {
   var cols = transpose(n);
   return map(??,m);
}</pre>
    <div style="position:absolute;display:none;" id="javascript_557_div"></div>
    
      </div>

      <div class="exercise">
<b>Exercise 2.39.</b>
        
        
        The <span class="javascriptinline">accumulate</span>
        function
        is also known as <span class="javascriptinline">fold_right</span>,
        because it combines the first element of the sequence with the result
        of combining all the elements to the right.  There is also a <span class="javascriptinline">fold_left</span>, which is 
        similar to <span class="javascriptinline">fold_right</span>, except
        that it combines elements working in the opposite direction:
        <div style="position:absolute;display:none;" id="javascript_559_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction fold_left(op,initial,sequence) {\n   function iter(result,rest) {\n      if (is_empty_list(rest)) \n         return result;\n      else\n         return iter(op(result,head(rest)),\n                     tail(rest));\n   }\n   return iter(initial,sequence);\n}\n\n// example\n\nfold_left(list,[],list(1,2,3))','javascript_559','',event,1.0);">function fold_left(op,initial,sequence) {
   function iter(result,rest) {
      if (is_empty_list(rest)) 
         return result;
      else
         return iter(op(result,head(rest)),
                     tail(rest));
   }
   return iter(initial,sequence);
}</pre>

        

        What are the values of
        
        <div style="position:absolute;display:none;" id="javascript_562_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// same as accumulate\nfunction fold_right(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                fold_right(op,initial,tail(sequence)));\n}\n          \nfunction divide(x,y) {\n   return x / y;\n}\n          \nfold_right(divide,1,list(1,2,3))','javascript_562','',event,1.0);">fold_right(divide,1,list(1,2,3))</pre>
        <div style="position:absolute;display:none;" id="javascript_563_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction fold_left(op,initial,sequence) {\n   function iter(result,rest) {\n      if (is_empty_list(rest)) \n         return result;\n      else\n         return iter(op(result,head(rest)),\n                     tail(rest));\n   }\n   return iter(initial,sequence);\n}\n        \nfunction divide(x,y) {\n   return x / y;\n}\n          \nfold_left(divide,1,list(1,2,3))','javascript_563','',event,1.0);">fold_left(divide,1,list(1,2,3))</pre>
        <div style="position:absolute;display:none;" id="javascript_564_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// same as accumulate\nfunction fold_right(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                fold_right(op,initial,tail(sequence)));\n}\n          \nfold_right(list,[],list(1,2,3))','javascript_564','',event,1.0);">fold_right(list,[],list(1,2,3))</pre>
        <div style="position:absolute;display:none;" id="javascript_565_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction fold_left(op,initial,sequence) {\n   function iter(result,rest) {\n      if (is_empty_list(rest)) \n         return result;\n      else\n         return iter(op(result,head(rest)),\n                     tail(rest));\n   }\n   return iter(initial,sequence);\n}\n        \nfold_left(list,[],list(1,2,3))','javascript_565','',event,1.0);">fold_left(list,[],list(1,2,3))</pre>

        Give a property that <span class="javascriptinline">op</span> should satisfy to guarantee that <span class="javascriptinline">fold_right</span> and <span class="javascriptinline">fold_left</span> will produce the same values for any
        sequence.
        <a name="ex:fold-right-left"></a>
    <div style="position:absolute;display:none;" id="javascript_566_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.40.</b>
        Complete the following definitions of <span class="javascriptinline">reverse</span>
        
        (exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:reverse">2.18</a>) in terms of <span class="javascriptinline">fold_right</span> and <span class="javascriptinline">fold_left</span> from exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:fold-right-left">2.39</a>:
        <div style="position:absolute;display:none;" id="javascript_567_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction reverse(sequence) {\n   return fold_right(function(x,y) { ?? },[],sequence);\n}\n\nfunction reverse(sequence) {\n   return fold_left(function(x,y) { ?? },[],sequence);','javascript_567','',event,1.0);">function reverse(sequence) {
   return fold_right(function(x,y) { ?? },[],sequence);
}

function reverse(sequence) {
   return fold_left(function(x,y) { ?? },[],sequence);</pre>
<div style="position:absolute;display:none;" id="javascript_568_div"></div>
      </div>
      

      <H4>Nested Mappings</H4>
        
      

      <a name="sec:nested-mappings"></a>
      

      <div class="normaltext">
        We can extend the sequence paradigm to include many
        computations that are commonly expressed using nested 
        loops.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_13"><a class="link" href="#footnote_13">13</a></a></span>
      </div>

      <div class="normaltext">
        Consider
        this problem: Given a positive integer <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_738.png"></span>, find all ordered pairs of
        distinct positive integers <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_739.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_740.png"></span>, where <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_741.png"></span>, such
        that <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_742.png"></span> is prime.  For example, if <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_743.png"></span> is 6, then the pairs are
        the following:
        <P><img src="img_javascript/latex_53.png"></P>
      </div>

      <div class="normaltext">
        A natural way to organize this computation is to generate the sequence
        of all ordered pairs of positive integers less than or equal to <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_744.png"></span>,
        filter to select those pairs whose sum is prime, and
        then, for each pair <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_745.png"></span> that passes through the filter, produce the triple
        <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_746.png"></span>.
      </div>

      <div class="normaltext">
        Here is a way to generate the sequence of pairs: For each integer
        <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_747.png"></span>, enumerate the integers <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_748.png"></span>, and for each such <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_749.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_750.png"></span>
        generate the pair <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_751.png"></span>.  In terms of sequence operations, we map
        along the sequence <span class="javascriptinline">enumerate_interval(1,n)</span>.  For each <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_752.png"></span> in
        this sequence, we map along the sequence <span class="javascriptinline">enumerate_interval(1,i-1)</span>.  For each <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_753.png"></span> in this latter sequence, we generate the pair
        <span class="javascriptinline">list(i,j)</span>.  This gives us a sequence of pairs for each <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_754.png"></span>.
        Combining all the sequences for all the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_755.png"></span> (by accumulating with <span class="javascriptinline">append</span>) produces the required sequence of pairs:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_14"><a class="link" href="#footnote_14">14</a></a></span>

        

        <div style="position:absolute;display:none;" id="javascript_570_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n          \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction enumerate_interval(low,high) {\n   if (low &gt; high)\n      return [];\n   else \n      return pair(low,\n                  enumerate_interval(low+1,high));\n}\n          \n// replace n below by the desired number\n        \naccumulate(append,\n           [],\n           map(function(i) {\n                  return \n                     map(function(j) { \n                            return list(i,j); \n                         },\n                         enumerate_interval(1,i-1))\n               },\n               enumerate_interval(1,n)))','javascript_570','',event,1.0);">accumulate(append,
           [],
           map(function(i) {
                  return 
                     map(function(j) { 
                            return list(i,j); 
                         },
                         enumerate_interval(1,i-1))
               },
               enumerate_interval(1,n)))</pre>
      </div>

      <div class="normaltext">
        The combination of mapping and accumulating with <span class="javascriptinline">append</span> is so common in this
        sort of program that we will isolate it as a separate
        function:
        <div style="position:absolute;display:none;" id="javascript_571_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n          \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction flatmap(proc,seq) {\n   return accumulate(append,[],map(proc,seq));\n}\n\n// example\n\nflatmap(function(x) { return x+1; },list(list(1,2),list(3,4)))','javascript_571','',event,1.0);">function flatmap(proc,seq) {
   return accumulate(append,[],map(proc,seq));
}</pre>

        
      </div>

      <div class="normaltext">
        Now filter this sequence of pairs to find those whose sum is prime. The
        filter predicate is called for each element of the sequence; its
        argument is a pair and it must extract the integers from the pair.
        Thus, the predicate to apply to each element in the sequence is
        <div style="position:absolute;display:none;" id="javascript_573_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction square(x) { return x * x; }\n                \nfunction smallest_divisor(n) {\n   return find_divisor(n,2);\n}\nfunction find_divisor(n,test_divisor) {\n   if (square(test_divisor) &gt; n) \n        return n;\n   else if (divides(test_divisor,n))\n        return test_divisor;\n   else return find_divisor(n, test_divisor + 1);\n}\nfunction divides(a,b) {\n   return b % a === 0;\n}\n          \nfunction is_prime(n) {\n   return n === smallest_divisor(n);\n}\n          \nfunction is_prime_sum(pair) {\n   return is_prime(head(pair)+head(tail(pair)));\n}\n\n// example\n\nis_prime_sum(list(8,9))','javascript_573','',event,1.0);">function is_prime_sum(pair) {
   return is_prime(head(pair)+head(tail(pair)));
}</pre>
        
      </div>

      <div class="normaltext">
        Finally, generate the sequence of results by mapping over the filtered
        pairs using the following
        function, which constructs a triple
        consisting of the two elements of the pair along with their sum:
        <div style="position:absolute;display:none;" id="javascript_575_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_pair_sum(pair) {\n   return list(head(pair),head(tail(pair)),\n               head(pair)+head(tail(pair)));\n}\n\n// example\n\nmake_pair_sum(list(8,9))','javascript_575','',event,1.0);">function make_pair_sum(pair) {
   return list(head(pair),head(tail(pair)),
               head(pair)+head(tail(pair)));
}</pre>
        
      </div>

      <div class="normaltext">
        Combining all these steps yields the complete
        function:
        <div style="position:absolute;display:none;" id="javascript_577_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction make_pair_sum(pair) {\n   return list(head(pair),head(tail(pair)),\n               head(pair)+head(tail(pair)));\n}\n        \nfunction filter(predicate,sequence) {\n   if (is_empty_list(sequence))\n      return [];\n   else if (predicate(head(sequence))) \n      return pair(head(sequence),\n                  filter(predicate,tail(sequence)));\n   else \n      return filter(predicate,tail(sequence));\n}\n        \nfunction square(x) { return x * x; }\n                \nfunction smallest_divisor(n) {\n   return find_divisor(n,2);\n}\nfunction find_divisor(n,test_divisor) {\n   if (square(test_divisor) &gt; n) \n        return n;\n   else if (divides(test_divisor,n))\n        return test_divisor;\n   else return find_divisor(n, test_divisor + 1);\n}\nfunction divides(a,b) {\n   return b % a === 0;\n}\n          \nfunction is_prime(n) {\n   return n === smallest_divisor(n);\n}\n          \nfunction is_prime_sum(pair) {\n   return is_prime(head(pair)+head(tail(pair)));\n}\n          \nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n          \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction flatmap(proc,seq) {\n   return accumulate(append,[],map(proc,seq));\n}\n          \nfunction enumerate_interval(low,high) {\n   if (low &gt; high)\n      return [];\n   else \n      return pair(low,\n                  enumerate_interval(low+1,high));\n}\n          \nfunction prime_sum_pairs(n) {\n   return map(make_pair_sum,\n              filter(is_prime_sum,\n                     flatmap(function(i) {\n                                return map(function(j) { \n                                              return list(i,j);\n                                           },\n                                           enumerate_interval(1,i-1));\n                             },\n                             enumerate_interval(1,n))));\n}\n\n// example\n\nprime_sum_pairs(15)','javascript_577','',event,1.0);">function prime_sum_pairs(n) {
   return map(make_pair_sum,
              filter(is_prime_sum,
                     flatmap(function(i) {
                                return map(function(j) { 
                                              return list(i,j);
                                           },
                                           enumerate_interval(1,i-1));
                             },
                             enumerate_interval(1,n))));
}</pre>

        

      </div>

      <div class="normaltext">
        Nested mappings are also useful for sequences other than those that
        enumerate intervals.  Suppose we wish to generate all the 
        
        
        permutations
        of a set <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_757.png"></span>; that is, all the ways of ordering the items in
        the set.  For instance, the permutations of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_758.png"></span> are
        <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_759.png"></span>, <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_760.png"></span>, <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_761.png"></span>, <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_762.png"></span>, <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_763.png"></span>, and
        <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_764.png"></span>.  Here is a plan for generating the permutations of&nbsp;<span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_765.png"></span>:
        For each item <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_766.png"></span> in <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_767.png"></span>, recursively generate the sequence of
        permutations of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_768.png"></span>,<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_15"><a class="link" href="#footnote_15">15</a></a></span> and adjoin
        <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_772.png"></span> to the front of each one.  This yields, for each <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_773.png"></span> in <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_774.png"></span>, the sequence
        of permutations of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_775.png"></span> that begin with&nbsp;<span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_776.png"></span>.  Combining these
        sequences for all <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_777.png"></span> gives all the permutations of&nbsp;<span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_778.png"></span>:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_16"><a class="link" href="#footnote_16">16</a></a></span>

        <div style="position:absolute;display:none;" id="javascript_579_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n          \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction flatmap(proc,seq) {\n   return accumulate(append,[],map(proc,seq));\n}\n          \nfunction filter(predicate,sequence) {\n   if (is_empty_list(sequence))\n      return [];\n   else if (predicate(head(sequence))) \n      return pair(head(sequence),\n                  filter(predicate,tail(sequence)));\n   else \n      return filter(predicate,tail(sequence));\n}\n        \nfunction remove(item,sequence) {\n   return filter(function(x) {\n                    return ! (x === item); \n                 },\n                 sequence);\n}\n        \nfunction permutations(s) {\n   if (is_empty_list(s)) \n      return list([]);\n   else\n      return flatmap(function(x) {\n                        return map(function(p) { \n                                      return pair(x,p);\n                                   },\n                                   permutations(remove(x,s)));\n                     },\n                     s);\n}\n\n// example\n\npermutations(list(1,2,3))','javascript_579','',event,1.0);">function permutations(s) {
   if (is_empty_list(s)) 
      return list([]);
   else
      return flatmap(function(x) {
                        return map(function(p) { 
                                      return pair(x,p);
                                   },
                                   permutations(remove(x,s)));
                     },
                     s);
}</pre>

        

      </div>

      <div class="normaltext">
        Notice how this strategy reduces the problem of generating
        permutations of <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_779.png"></span> to the problem of generating the permutations of
        sets with fewer elements than <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_780.png"></span>.  In the terminal case, we work our
        way down to the empty list, which represents a set of no elements.
        For this, we generate <span class="javascriptinline">list([])</span>, which is a sequence with one
        item, namely the set with no elements.  The <span class="javascriptinline">remove</span>
        function
        used in <span class="javascriptinline">permutations</span> returns all the items in a given sequence
        except for a given item.  This can be expressed as a simple filter:
        <div style="position:absolute;display:none;" id="javascript_581_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction filter(predicate,sequence) {\n   if (is_empty_list(sequence))\n      return [];\n   else if (predicate(head(sequence))) \n      return pair(head(sequence),\n                  filter(predicate,tail(sequence)));\n   else \n      return filter(predicate,tail(sequence));\n}\n        \nfunction remove(item,sequence) {\n   return filter(function(x) {\n                    return ! (x === item); \n                 },\n                 sequence);\n}\n\n// example\n\nremove(3,list(1,2,3,4,5))','javascript_581','',event,1.0);">function remove(item,sequence) {
   return filter(function(x) {
                    return ! (x === item); 
                 },
                 sequence);
}</pre>
        
      </div>

      <div class="exercise">
<b>Exercise 2.41.</b>
        Define a
        function

        
        <span class="javascriptinline">unique_pairs</span> that, given an integer <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_781.png"></span>,
        generates the sequence of pairs <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_782.png"></span> with <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_783.png"></span>.  Use <span class="javascriptinline">unique_pairs</span> to simplify the definition of <span class="javascriptinline">prime_sum_pairs</span>
        given above.
    <div style="position:absolute;display:none;" id="javascript_583_div"></div>
    
      </div>

      <div class="exercise">
<b>Exercise 2.42.</b>
        Write a
        function
        to find all ordered
        triples of distinct positive integers <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_784.png"></span>, <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_785.png"></span>, and&nbsp;<span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_786.png"></span> less than or
        equal to a given integer <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_787.png"></span> that sum to a given integer <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_788.png"></span>.
    <div style="position:absolute;display:none;" id="javascript_585_div"></div>
    
      </div>

      <div class="exercise">
<b>Exercise 2.43.</b>


              <p><div align="center"><table width="100%">
<tr><td align="center">
<img src="img_original/ch2-Z-G-23.gif" border="0">
                <a name="fig:8queens"></a>
                
              </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  8</b>&nbsp;&nbsp;&nbsp;A solution to the eight-queens puzzle.
                </div></caption>
<tr><td></td></tr>
</table></div></p>
        The 
        
        
        &#147;eight-queens puzzle&#148; asks how to place eight queens on a
        chessboard so that no queen is in check from any other (i.e., no two
        queens are in the same row, column, or diagonal).  One possible
        solution is shown in figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:8queens">2.</a>.  One way to solve the
        puzzle is to work across the board, placing a queen in each column.
        Once we have placed <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_789.png"></span> queens, we must place the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_790.png"></span>th queen in a
        position where it does not check any of the queens already on the
        board.  We can formulate this approach recursively: Assume that we
        have already generated the sequence of all possible ways to place
        <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_791.png"></span> queens in the first <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_792.png"></span> columns of the board.  For each of
        these ways, generate an extended set of positions by placing a queen
        in each row of the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_793.png"></span>th column.  Now filter these, keeping only
        the positions for which the queen in the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_794.png"></span>th column is safe with
        respect to the other queens.  This produces the sequence of all ways
        to place <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_795.png"></span> queens in the first <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_796.png"></span> columns.  By continuing this
        process, we will produce not only one solution, but all solutions to
        the puzzle.

        We implement this solution as a
        function
        <span class="javascriptinline">queens</span>, which returns
        a sequence of all solutions to the problem of placing <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_797.png"></span> queens on an
        <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_798.png"></span> chessboard.  The function <span class="javascriptinline">queens</span> has an internal
        function
        <span class="javascriptinline">queens_cols</span> that returns the sequence of all ways to place queens in
        the first <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_799.png"></span> columns of the board.

        
        
        

        <div style="position:absolute;display:none;" id="javascript_590_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// function adjoin_position to be written by student\n          \n// function empty_board to be written by student\n          \n// function is_safe to be written by student\n          \nfunction accumulate(op,initial,sequence) {\n   if (is_empty_list(sequence))\n      return initial;\n   else \n      return op(head(sequence),\n                accumulate(op,initial,tail(sequence)));\n}\n          \nfunction append(list1,list2) {\n   if (is_empty_list(list1))\n      return list2;\n   else return pair(head(list1),append(tail(list1),list2));\n}\n          \nfunction map(fun,items) {\n   if (is_empty_list(items)) \n      return [];\n   else return pair(fun(head(items)),\n                    map(fun,tail(items)));\n}\n          \nfunction flatmap(proc,seq) {\n   return accumulate(append,[],map(proc,seq));\n}\n          \nfunction queeens(board_size) {\n   function queen_cols(k) {\n      if (k===0) \n         return list(empty_board);\n      else\n         return filter(function(positions) {\n                          return is_safe(k,positions);\n                       },\n                       flatmap(function(rest_of_queens) {\n                                  return map(function(new_row) {\n                                                return adjoin_position(new_row,\n                                                                       k,\n                                                                       rest_of_queens);\n                                             },\n                                             enumerate_interval(1,board_size));\n                               },\n                               queens_cols(k-1)));\n   }\n   return queen_cols(board_size);\n}','javascript_590','',event,1.0);">function queeens(board_size) {
   function queen_cols(k) {
      if (k===0) 
         return list(empty_board);
      else
         return filter(function(positions) {
                          return is_safe(k,positions);
                       },
                       flatmap(function(rest_of_queens) {
                                  return map(function(new_row) {
                                                return adjoin_position(new_row,
                                                                       k,
                                                                       rest_of_queens);
                                             },
                                             enumerate_interval(1,board_size));
                               },
                               queens_cols(k-1)));
   }
   return queen_cols(board_size);
}</pre>

        In this
        function
        <span class="javascriptinline">rest_of_queens</span> is a way to place <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_800.png"></span> queens
        in the first <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_801.png"></span> columns, and <span class="javascriptinline">new_row</span> is a proposed row in
        which to place the queen for the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_802.png"></span>th column.  Complete the program
        by implementing the representation for sets of board positions,
        including the
        function
        <span class="javascriptinline">adjoin_position</span>, which adjoins a new row-column
        position to a set of positions, and <span class="javascriptinline">empty_board</span>, which
        represents an empty set of positions.  You must also write the
        function
        <span class="javascriptinline">is_safe</span>, which determines for a set of positions,
        whether the queen in the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_803.png"></span>th column is safe with respect to the
        others.  (Note that we need only check whether the new queen is
        safe—the other queens are already guaranteed safe with respect to
        each other.)
        <a name="ex:8queens"></a>
      </div>

      <div class="exercise">
<b>Exercise 2.44.</b>
        Louis Reasoner is having a terrible time doing exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:8queens">2.43</a>.  His
        <span class="javascriptinline">queens</span>
        function
        seems to work, but it runs extremely slowly.
        (Louis never does manage to wait long enough for it to solve even the
        <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_804.png"></span> case.)  When Louis asks Eva Lu Ator for help, she points
        out that he has interchanged the order of the nested mappings in the
        <span class="javascriptinline">flatmap</span>, writing it as
        <form name="form_591" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_591.png"></form>

        Explain why this interchange makes the program run slowly.  Estimate
        how long it will take Louis&#146;s program to solve the eight-queens
        puzzle, assuming that the program in exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:8queens">2.43</a> solves
        the puzzle in time <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_805.png"></span>.
      </div>
      
      
      
      
    

    <h3><a name="subsection_2_2_4">2.2.4&nbsp;
        Example: A Picture Language
      </a></h3>
      

      <a name="sec:graphics"></a>
      

      <div class="normaltext">
        This section presents a simple language for drawing
        pictures that illustrates the
        power of data abstraction and closure,
        and also exploits higher-order
        functions
        in
        an essential way.  The language
        is designed to make it easy to experiment with patterns
        such as the ones in figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:sqlimit-designs">2.9</a>, which are
        composed of repeated elements that are shifted and 
        scaled.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_17"><a class="link" href="#footnote_17">17</a></a></span> In this language,
        the data objects being combined
        are represented as
        functions
        rather than as list structure.
        Just as <span class="javascriptinline">pair</span>, which satisfies the 
        
        closure property,
        allowed us to easily build arbitrarily complicated
        list structure, the operations in this language, which also
        satisfy the closure property, allow us to easily build
        arbitrarily complicated patterns.

              <p><div align="center"><table width="100%">
<tr><td align="center">
                <img src="img_original/ch2-Z-G-24.gif" border="0">
                &nbsp;&nbsp;&nbsp;
                <img src="img_original/ch2-Z-G-25.gif" border="0">
                <a name="fig:sqlimit-designs"></a>
                
              </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  9</b>&nbsp;&nbsp;&nbsp;Designs generated with the picture language.
                </div></caption>
<tr><td></td></tr>
</table></div></p>
      </div>

      <H4>The picture language</H4>
        
      

      <div class="normaltext">
        When we began our study of programming in
        section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_1.html')">1.1</a>, we emphasized the
        importance of describing a language by focusing on the language&#146;s
        primitives, its means of combination, and its means of abstraction.
        We&#146;ll follow that framework here.
      </div>

      <div class="normaltext">
        Part of the elegance of this picture language is that there is
        only one kind of element, called a 
        
        <em>painter</em>.  A painter
        draws an image that is shifted and scaled to fit within a designated
        
        parallelogram-shaped frame.  For example, there&#146;s a primitive painter
        we&#146;ll call <span class="javascriptinline">wave</span> that makes a crude line drawing, as
        shown in figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:wave">2.10</a>.

              <p><div align="center"><table width="100%">
<tr><td align="center">
                <img src="img_original/ch2-Z-G-26.gif" border="0">
                &nbsp;&nbsp;&nbsp;
                <img src="img_original/ch2-Z-G-27.gif" border="0">

                <img src="img_original/ch2-Z-G-28.gif" border="0">
                &nbsp;&nbsp;&nbsp;
                <img src="img_original/ch2-Z-G-29.gif" border="0">

                <a name="fig:wave"></a>
                
              </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  10</b>&nbsp;&nbsp;&nbsp;Images produced by the <span class="javascriptinline">wave</span> painter, with respect
        to four different frames.  The frames, shown with dotted lines, are not
        part of the images.
                </div></caption>
<tr><td></td></tr>
</table></div></p>

        The actual shape of the drawing depends on the frame—all
        four images in figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:wave">2.10</a> are produced by the same <span class="javascriptinline">wave</span> painter, but with respect to four different frames.  
        
            All our painters will draw in a square-shaped viewing area of size 400x400 
            pixels. We will handle the definition of frames in more detail below. For 
            now, let us assume that we have a particular frame, 
            called <span class="javascriptinline">full_frame</span>, 
            which refers to the the entire viewing area. Now we can apply our painter
            <span class="javascriptinline">wave</span> to 
            <span class="javascriptinline">full_frame</span>, as follows.

            

            

            <div style="position:absolute;display:none;" id="javascript_594_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nwave(full_frame);','javascript_594','svg()',event,1.0);">wave(full_frame);</pre>
          

        Painters can be more elaborate than this:
        The primitive
        painter called <span class="javascriptinline">rogers</span> paints a picture of MIT&#146;s founder,
        William Barton Rogers, as shown in figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:rogers">2.11</a>.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_18"><a class="link" href="#footnote_18">18</a></a></span>

        
            
            <div style="position:absolute;display:none;" id="javascript_596_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nrogers(full_frame);','javascript_596','svg()',event,1.0);">rogers(full_frame);</pre>

          Our Javascript environment provides a function 
          <span class="javascriptinline">make_painter_from_url</span>, which generates
          a painter for the picture that can be obtained using a given URL 
          (Uniform Resource Locator).

            <div style="position:absolute;display:none;" id="javascript_597_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar bird = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/bird.gif&quot;);\nbird(full_frame);','javascript_597','svg()',event,1.0);">var bird = make_painter_from_url(
           "http://www.comp.nus.edu.sg/~henz/sicp/img_original/bird.gif");
bird(full_frame);</pre>

          

        <p><div align="center"><table width="100%">
<tr><td align="center">
          <img src="img_original/ch2-Z-G-30.gif" border="0">
          &nbsp;&nbsp;&nbsp;
          <img src="img_original/ch2-Z-G-31.gif" border="0">

          <img src="img_original/ch2-Z-G-32.gif" border="0">
          &nbsp;&nbsp;&nbsp;
          <img src="img_original/ch2-Z-G-33.gif" border="0">

          <a name="fig:rogers"></a>
          
        </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  11</b>&nbsp;&nbsp;&nbsp;Images of William Barton Rogers, founder and first
          president of MIT, painted with respect to the same four frames as in
          figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:wave">2.10</a> (original image reprinted with the permission
          of the MIT Museum).
          </div></caption>
<tr><td></td></tr>
</table></div></p>
      </div>

      <div class="normaltext">
        The four images in figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:rogers">2.11</a>
        are drawn with respect to the same four frames
        as the <span class="javascriptinline">wave</span> images in figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:wave">2.10</a>.
      </div>

      <div class="normaltext">
        
        To combine images,
        we use various operations that construct new painters
        from given painters.
        For example, the 
        
        <span class="javascriptinline">beside</span> operation takes two painters and produces a new,
        compound painter that draws the first painter&#146;s image in the left half
        of the frame and the second painter&#146;s image in the right half of the frame.
        Similarly, 
        
        <span class="javascriptinline">below</span> takes two painters and produces a compound
        painter that draws the first painter&#146;s image below the second
        painter&#146;s image.
        Some operations transform a single painter to produce
        a new painter.  For example, 
        
        <span class="javascriptinline">flip_vert</span> takes a painter and
        produces a painter that draws its image upside-down, and
        
        <span class="javascriptinline">flip_horiz</span> produces a painter that draws the original
        painter&#146;s image left-to-right reversed.
      </div>

      <div class="normaltext">
        Figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:build-up-wave">2.12</a> shows the drawing of a painter called
        <span class="javascriptinline">wave4</span> that is built up in two stages starting from <span class="javascriptinline">wave</span>:

        <p><div align="center"><table width="100%">
<tr><td align="center">
        <img src="img_original/ch2-Z-G-34.gif" border="0">
        
        <a name="fig:build-up-wave"></a>
        </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  12</b>&nbsp;&nbsp;&nbsp;Creating a complex figure,
        starting from the <span class="schemeinline">wave</span> painter of figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:wave">2.10</a>.
        </div></caption>
<tr><td></td></tr>
</table></div></p>

        <div style="position:absolute;display:none;" id="javascript_598_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction flip_vert(painter) {\n   return transform_painter(painter,\n                            make_vect(0.0,1.0),  // new origin\n                            make_vect(1.0,1.0),  // new end of edge1\n                            make_vect(0.0,0.0)); // new end of edge2\n}\n        \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar wave2 = beside(wave,flip_vert(wave));\n\n// example\n\nwave2(full_frame);','javascript_598','svg()',event,1.0);">var wave2 = beside(wave,flip_vert(wave));</pre>

        

        <img src="img_original/ch2-Z-G-35.gif" border="0">
        <div style="position:absolute;display:none;" id="javascript_600_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction flip_vert(painter) {\n   return transform_painter(painter,\n                            make_vect(0.0,1.0),  // new origin\n                            make_vect(1.0,1.0),  // new end of edge1\n                            make_vect(0.0,0.0)); // new end of edge2\n}\n        \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar wave2 = beside(wave,flip_vert(wave));\n        \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar wave4 = below(wave2,wave2);\n\n// example\n\nwave4(full_frame);','javascript_600','svg()',event,1.0);">var wave4 = below(wave2,wave2);</pre>

        


      </div>

      <div class="normaltext">
        
        In building up a complex image in this manner we are exploiting the
        fact that painters are closed under the language&#146;s means of
        combination.  The <span class="javascriptinline">beside</span> or <span class="javascriptinline">below</span> of two painters is
        itself a painter; therefore, we can use it as an element in making
        more complex painters.  As with building up list structure using <span class="javascriptinline">pair</span>, the closure of our data under the means of combination is
        crucial to the ability to create complex structures while using only a
        few operations.
      </div>

      <div class="normaltext">
        Once we can combine painters, we would like to be able to abstract
        typical patterns of combining painters.
        We will implement the painter operations as Scheme
        functions.
        This means that we don&#146;t need a special abstraction mechanism
        in the picture language:
        Since the means of combination
        are ordinary Scheme
        functions, we automatically have the capability
        to do anything with painter operations that we can do with
        functions.
        For example, we can abstract the pattern in <span class="javascriptinline">wave4</span> as

        <form name="form_602" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_602.png"></form>

        and define <span class="javascriptinline">wave4</span> as an instance of this pattern:

        <div style="position:absolute;display:none;" id="javascript_603_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction flip_vert(painter) {\n   return transform_painter(painter,\n                            make_vect(0.0,1.0),  // new origin\n                            make_vect(1.0,1.0),  // new end of edge1\n                            make_vect(0.0,0.0)); // new end of edge2\n}\n        \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction square_of_four(tl,tr,bl,br) {\n   return function(painter) {\n             var top = beside(tl(painter),tr(painter));\n             var bottom = beside(bl(painter),br(painter));\n             return below(bottom,top);\n          }\n}\n          \nfunction identity(x) {\n   return x;\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction flip_vert(painter) {\n   return transform_painter(painter,\n                            make_vect(0.0,1.0),  // new origin\n                            make_vect(1.0,1.0),  // new end of edge1\n                            make_vect(0.0,0.0)); // new end of edge2\n}\n        \nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction flipped_pairs(painter) {\n   var painter2 = beside(painter,flip_vert(painter));\n   return below(painter2,painter2);\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nvar wave4 = flipped_pairs(wave);\n\n// example\n\nwave4(full_frame);','javascript_603','svg()',event,1.0);">var wave4 = flipped_pairs(wave);</pre>

        

      </div>

      <div class="normaltext">
        We can also define recursive operations.
        Here&#146;s one that makes painters split and branch
        towards the right as shown in figures&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:split-plans">2.13</a>
        and &nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:splits">2.14</a>:
        <div style="position:absolute;display:none;" id="javascript_605_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction right_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = right_split(painter,n - 1);\n      return beside(painter,below(smaller,smaller));\n   }\n}\n\n// example\n\nright_split(wave,4)(full_frame);','javascript_605','svg()',event,1.0);">function right_split(painter,n) {
   if (n === 0) 
      return painter;
   else {
      var smaller = right_split(painter,n - 1);
      return beside(painter,below(smaller,smaller));
   }
}</pre>

        
        
      </div>

      <div class="normaltext">
        <p><div align="center"><table width="100%">
<tr><td align="center">
          <img src="img_original/ch2-Z-G-36.gif" border="0">
          <p></p>
          <span class="javascriptinline">right_split</span> <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_806.png"></span>
          <p></p>
          <img src="img_original/ch2-Z-G-37.gif" border="0">
          <p></p>
          <span class="javascriptinline">corner_split</span> <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_807.png"></span>
          
        <a name="fig:split-plans"></a>
        </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  13</b>&nbsp;&nbsp;&nbsp;Recursive plans for <span class="javascriptinline">right_split</span> and <span class="javascriptinline">corner_split</span>.</div></caption>
<tr><td></td></tr>
</table></div></p>
      </div>


      <div class="normaltext">
        We can produce balanced patterns by branching upwards
        as well as towards the right (see exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:up-split">2.45</a>
        and figures&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:split-plans">2.13</a> and &nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:splits">2.14</a>):

        <div style="position:absolute;display:none;" id="javascript_608_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction right_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = right_split(painter,n - 1);\n      return beside(painter,below(smaller,smaller));\n   }\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction up_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = up_split(painter,n - 1);\n      return below(painter,beside(smaller,smaller));\n   }\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction corner_split(painter,n) {\n   if (n === 0)\n      return painter;\n   else {\n      var up = up_split(painter,n-1);\n      var right = right_split(painter,n-1);\n      var top_left = beside(up,up);\n      var bottom_right = below(right,right);\n      var corner = corner_split(painter,n-1);\n      return beside(below(painter,top_left),\n                    below(bottom_right,corner));\n   }\n}\n\n// example\n\ncorner_split(wave,4)(full_frame);','javascript_608','svg()',event,1.0);">function corner_split(painter,n) {
   if (n === 0)
      return painter;
   else {
      var up = up_split(painter,n-1);
      var right = right_split(painter,n-1);
      var top_left = beside(up,up);
      var bottom_right = below(right,right);
      var corner = corner_split(painter,n-1);
      return beside(below(painter,top_left),
                    below(bottom_right,corner));
   }
}</pre>

        
 
        
      </div>

      <div class="normaltext">
        <p><div align="center"><table width="100%">
<tr><td align="center">
          <img src="img_original/ch2-Z-G-38.gif" border="0">
          <div style="position:absolute;display:none;" id="javascript_611_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction right_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = right_split(painter,n - 1);\n      return beside(painter,below(smaller,smaller));\n   }\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nright_split(wave,4)\n\n// example\n\nright_split(wave,4)(full_frame);','javascript_611','svg()',event,1.0);">right_split(wave,4)</pre>
          <p></p>
          <img src="img_original/ch2-Z-G-39.gif" border="0">
          <div style="position:absolute;display:none;" id="javascript_612_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction right_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = right_split(painter,n - 1);\n      return beside(painter,below(smaller,smaller));\n   }\n}\n          \nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nright_split(rogers,4)\n\n// example\n\nright_split(rogers,4)(full_frame);','javascript_612','svg()',event,1.0);">right_split(rogers,4)</pre>
          <p></p>
          <img src="img_original/ch2-Z-G-40.gif" border="0">
          <div style="position:absolute;display:none;" id="javascript_613_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction right_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = right_split(painter,n - 1);\n      return beside(painter,below(smaller,smaller));\n   }\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction up_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = up_split(painter,n - 1);\n      return below(painter,beside(smaller,smaller));\n   }\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction corner_split(painter,n) {\n   if (n === 0)\n      return painter;\n   else {\n      var up = up_split(painter,n-1);\n      var right = right_split(painter,n-1);\n      var top_left = beside(up,up);\n      var bottom_right = below(right,right);\n      var corner = corner_split(painter,n-1);\n      return beside(below(painter,top_left),\n                    below(bottom_right,corner));\n   }\n}\n        \ncorner_split(wave,4)\n\n// example\n\ncorner_split(wave,4)(full_frame);','javascript_613','svg()',event,1.0);">corner_split(wave,4)</pre>
          <p></p>
          <img src="img_original/ch2-Z-G-41.gif" border="0">
          <div style="position:absolute;display:none;" id="javascript_614_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction right_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = right_split(painter,n - 1);\n      return beside(painter,below(smaller,smaller));\n   }\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction up_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = up_split(painter,n - 1);\n      return below(painter,beside(smaller,smaller));\n   }\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction corner_split(painter,n) {\n   if (n === 0)\n      return painter;\n   else {\n      var up = up_split(painter,n-1);\n      var right = right_split(painter,n-1);\n      var top_left = beside(up,up);\n      var bottom_right = below(right,right);\n      var corner = corner_split(painter,n-1);\n      return beside(below(painter,top_left),\n                    below(bottom_right,corner));\n   }\n}\n        \ncorner_split(rogers,4)\n\n// example\n\ncorner_split(rogers,4)(full_frame);','javascript_614','svg()',event,1.0);">corner_split(rogers,4)</pre>
          
          <a name="fig:splits"></a>
        </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  14</b>&nbsp;&nbsp;&nbsp;
            The recursive operations <span class="javascriptinline">right_split</span> and <span class="javascriptinline">corner_split</span> applied to the painters <span class="javascriptinline">wave</span> and <span class="javascriptinline">rogers</span>.
            Combining four <span class="javascriptinline">corner_split</span> figures produces
            symmetric <span class="javascriptinline">square_limit</span> designs as shown
        in figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:sqlimit-designs">2.9</a>.
          </div></caption>
<tr><td></td></tr>
</table></div></p>
      </div>

      <div class="normaltext">
        By placing four copies of a <span class="javascriptinline">corner_split</span>
        appropriately, we obtain a pattern called <span class="javascriptinline">square_limit</span>, whose
        application to <span class="javascriptinline">wave</span> and <span class="javascriptinline">rogers</span> is shown in
        figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:sqlimit-designs">2.9</a>:
        <div style="position:absolute;display:none;" id="javascript_615_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction right_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = right_split(painter,n - 1);\n      return beside(painter,below(smaller,smaller));\n   }\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction up_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = up_split(painter,n - 1);\n      return below(painter,beside(smaller,smaller));\n   }\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction corner_split(painter,n) {\n   if (n === 0)\n      return painter;\n   else {\n      var up = up_split(painter,n-1);\n      var right = right_split(painter,n-1);\n      var top_left = beside(up,up);\n      var bottom_right = below(right,right);\n      var corner = corner_split(painter,n-1);\n      return beside(below(painter,top_left),\n                    below(bottom_right,corner));\n   }\n}\n        \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction flip_horiz(painter) {\n   return transform_painter(painter,\n                            make_vect(1.0,0.0),  // new origin\n                            make_vect(0.0,0.0),  // new end of edge1\n                            make_vect(1.0,1.0)); // new end of edge2\n}\n        \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction flip_vert(painter) {\n   return transform_painter(painter,\n                            make_vect(0.0,1.0),  // new origin\n                            make_vect(1.0,1.0),  // new end of edge1\n                            make_vect(0.0,0.0)); // new end of edge2\n}\n        \nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction square_limit(painter,n) {\n   var quarter = corner_split(painter,n);\n   var half = beside(flip_horiz(quarter),quarter);\n   return below(flip_vert(half),half);\n}\n\n// example\n\nsquare_limit(rogers,5)(full_frame);','javascript_615','svg()',event,1.0);">function square_limit(painter,n) {
   var quarter = corner_split(painter,n);
   var half = beside(flip_horiz(quarter),quarter);
   return below(flip_vert(half),half);
}</pre>

        

      </div>

      <div class="exercise">
<b>Exercise 2.45.</b>
        Define the
        function

        
        <span class="javascriptinline">up_split</span> used by <span class="javascriptinline">corner_split</span>.
        It is similar to <span class="javascriptinline">right_split</span>, except that it switches the
        roles of <span class="javascriptinline">below</span> and <span class="javascriptinline">beside</span>.
        <a name="ex:up-split"></a>

        

        

<div style="position:absolute;display:none;" id="javascript_619_div"></div>
      </div>

      <H4>Higher-order operations</H4>
        
      

      

      <div class="normaltext">
        In addition to abstracting patterns of combining painters, we can work
        at a higher level, abstracting patterns of combining painter operations.
        That is, we can view the painter operations as elements to manipulate
        and can write means of combination for these elements—functions
        that
        take painter operations as arguments and create new painter operations.
      </div>

      <div class="normaltext">
        For example, <span class="javascriptinline">flipped_pairs</span> and <span class="javascriptinline">square_limit</span> each
        arrange four copies of a painter&#146;s image in a square pattern; they differ
        only in how they orient the copies.
        One way to abstract this pattern of painter combination is with
        the following
        function, which takes four one-argument painter operations
        and produces a painter operation that transforms a given
        painter with those four operations and arranges the results in a square.
        The functions <span class="javascriptinline">tl</span>, <span class="javascriptinline">tr</span>, <span class="javascriptinline">bl</span>, and <span class="javascriptinline">br</span> are the
        transformations to apply to the top left copy, the top right copy,
        the bottom left copy, and the bottom right copy, respectively.

        <div style="position:absolute;display:none;" id="javascript_620_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction square_of_four(tl,tr,bl,br) {\n   return function(painter) {\n             var top = beside(tl(painter),tr(painter));\n             var bottom = beside(bl(painter),br(painter));\n             return below(bottom,top);\n          }\n}\n\n// example\n\nsquare_of_four(rogers,rogers,rogers,rogers)(full_frame);','javascript_620','svg()',event,1.0);">function square_of_four(tl,tr,bl,br) {
   return function(painter) {
             var top = beside(tl(painter),tr(painter));
             var bottom = beside(bl(painter),br(painter));
             return below(bottom,top);
          }
}</pre>

        

        Then <span class="javascriptinline">flipped_pairs</span> can be defined in terms
        of <span class="javascriptinline">square_of_four</span> as follows:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_19"><a class="link" href="#footnote_19">19</a></a></span>

        <div style="position:absolute;display:none;" id="javascript_623_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction square_of_four(tl,tr,bl,br) {\n   return function(painter) {\n             var top = beside(tl(painter),tr(painter));\n             var bottom = beside(bl(painter),br(painter));\n             return below(bottom,top);\n          }\n}\n          \nfunction identity(x) {\n   return x;\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction flip_vert(painter) {\n   return transform_painter(painter,\n                            make_vect(0.0,1.0),  // new origin\n                            make_vect(1.0,1.0),  // new end of edge1\n                            make_vect(0.0,0.0)); // new end of edge2\n}\n        \nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction flipped_pairs(painter) {\n   var combine4 = square_of_four(identity,flip_vert,\n                                 identity,flip_vert);\n   return combine4(painter);\n}\n\n// example\n\nflipped_pairs(rogers)(full_frame);','javascript_623','svg()',event,1.0);">function flipped_pairs(painter) {
   var combine4 = square_of_four(identity,flip_vert,
                                 identity,flip_vert);
   return combine4(painter);
}</pre>

        

        and <span class="javascriptinline">square_limit</span> can be expressed as<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_20"><a class="link" href="#footnote_20">20</a></a></span>

        <div style="position:absolute;display:none;" id="javascript_625_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction square_of_four(tl,tr,bl,br) {\n   return function(painter) {\n             var top = beside(tl(painter),tr(painter));\n             var bottom = beside(bl(painter),br(painter));\n             return below(bottom,top);\n          }\n}\n          \nfunction identity(x) {\n   return x;\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction flip_vert(painter) {\n   return transform_painter(painter,\n                            make_vect(0.0,1.0),  // new origin\n                            make_vect(1.0,1.0),  // new end of edge1\n                            make_vect(0.0,0.0)); // new end of edge2\n}\n        \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction flip_horiz(painter) {\n   return transform_painter(painter,\n                            make_vect(1.0,0.0),  // new origin\n                            make_vect(0.0,0.0),  // new end of edge1\n                            make_vect(1.0,1.0)); // new end of edge2\n}\n        \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction rotate180(painter) {\n   return transform_painter(painter,\n                            make_vect(1.0,1.0),  // new origin\n                            make_vect(0.0,1.0),  // new end of edge1\n                            make_vect(1.0,0.0)); // new end of edge2\n}\n        \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction right_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = right_split(painter,n - 1);\n      return beside(painter,below(smaller,smaller));\n   }\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction up_split(painter,n) {\n   if (n === 0) \n      return painter;\n   else {\n      var smaller = up_split(painter,n - 1);\n      return below(painter,beside(smaller,smaller));\n   }\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar wave = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/my_wave.png&quot;);\n              \nfunction corner_split(painter,n) {\n   if (n === 0)\n      return painter;\n   else {\n      var up = up_split(painter,n-1);\n      var right = right_split(painter,n-1);\n      var top_left = beside(up,up);\n      var bottom_right = below(right,right);\n      var corner = corner_split(painter,n-1);\n      return beside(below(painter,top_left),\n                    below(bottom_right,corner));\n   }\n}\n        \nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nfunction square_limit(painter,n) {\n   var combine4 = square_of_four(flip_horiz,identity,\n                                 rotate180,flip_vert);\n   return combine4(corner_split(painter,n));\n}\n\n// example\n\nsquare_limit(rogers,5)(full_frame);','javascript_625','svg()',event,1.0);">function square_limit(painter,n) {
   var combine4 = square_of_four(flip_horiz,identity,
                                 rotate180,flip_vert);
   return combine4(corner_split(painter,n));
}</pre>

        

      </div>

      <div class="exercise">
<b>Exercise 2.46.</b>
        The functions <span class="javascriptinline">right_split</span> and <span class="javascriptinline">up_split</span> can be expressed as
        instances of a general splitting operation.
        Define a
        function

        
        <span class="javascriptinline">split</span> with the property that evaluating
        <form name="form_627" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_627.png"></form>

        produces
        functions
        <span class="javascriptinline">right_split</span> and <span class="javascriptinline">up_split</span> with the same
        behaviors as the ones already defined.
        <a name="ex:splitting"></a>
    <div style="position:absolute;display:none;" id="javascript_628_div"></div>
      </div>

      <H4>Frames</H4>
        
      

      
      <div class="normaltext">
        Before we can show how to implement painters and their
        means of combination, we must first consider
        
        frames.  A frame can be described by three vectors—an origin vector
        and two edge vectors.  The origin vector specifies the offset of the
        frame&#146;s origin from some absolute origin in the plane, and the edge
        vectors specify the offsets of the frame&#146;s corners from its origin.
        If the edges are perpendicular, the frame will be rectangular.
        Otherwise the frame will be a more general parallelogram.
      </div>

      <div class="normaltext">
        Figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:frame">2.15</a> shows a frame and its associated vectors.  In
        accordance with data abstraction, we need not be
        specific yet about how frames are represented, other than to say that
        there is a constructor 
        
        <span class="javascriptinline">make_frame</span>, which takes three vectors and
        produces a frame, and three corresponding selectors 
        
        <span class="javascriptinline">origin_frame</span>, 
        
        <span class="javascriptinline">edge1_frame</span>, and 
        
        <span class="javascriptinline">edge2_frame</span> (see
        exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:implement-frames">2.48</a>).

        <p><div align="center"><table width="100%">
<tr><td align="center">
<img src="img_original/ch2-Z-G-42.gif" border="0">
        
        <a name="fig:frame"></a>
        </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  15</b>&nbsp;&nbsp;&nbsp;A frame is described by three vectors—an origin and two edges.
        </div></caption>
<tr><td></td></tr>
</table></div></p>
      </div>

      <div class="normaltext">
        
        We will use coordinates in the unit square (<span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_808.png"></span>)
        to specify images.
        With each frame, we associate a 
        
        <em>frame coordinate map</em>, which
        will be used to shift and scale images to fit the frame.  The map
        transforms the unit square into the frame by
        mapping the vector <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_809.png"></span> to the vector sum
        <P><img src="img_javascript/latex_54.png"></P>
        For example, <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_810.png"></span> is mapped to the origin of the frame, <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_811.png"></span> to
        the vertex diagonally opposite the origin, and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_812.png"></span> to the
        center of the frame.  We can create a frame&#146;s coordinate map with the
        following
        function:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_21"><a class="link" href="#footnote_21">21</a></a></span>

          

          

        <div style="position:absolute;display:none;" id="javascript_631_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}','javascript_631','svg()',event,1.0);">function frame_coord_map(frame) {
   return function(v) {
             return add_vect(origin_frame(frame),
                             add_vect(scale_vect(xcor_vect(v),
                                                 edge1_frame(frame)),
                                      scale_vect(ycor_vect(v),
                                                 edge2_frame(frame))));
          };
}</pre>
      </div>

      <div class="normaltext">
        Observe that applying <span class="javascriptinline">frame_coord_map</span> to a frame returns
        a
        function
        that, given a vector, returns a vector.
        If the argument vector is in the unit square, the result vector
        will be in the frame.  For example,
        <form name="form_632" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_632.png"></form>
        returns the same vector as
        <form name="form_633" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_633.png"></form>
      </div>

      <div class="exercise">
<b>Exercise 2.47.</b><a name="ex:vectors"></a>
        
        
        A two-dimensional vector <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_813.png"></span> running from the origin to a point
        can be represented as a pair
        consisting of an <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_814.png"></span>-coordinate and a <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_815.png"></span>-coordinate.  Implement a data
        abstraction for vectors by giving a constructor 
        
        <span class="javascriptinline">make_vect</span> and
        corresponding selectors 
        
        <span class="javascriptinline">xcor_vect</span> and 
        
        <span class="javascriptinline">ycor_vect</span>.  In
        terms of your selectors and constructor, implement
        functions

        
        <span class="javascriptinline">add_vect</span>, 
        
        <span class="javascriptinline">sub_vect</span>, and 
        
        <span class="javascriptinline">scale_vect</span> that perform
        the operations vector addition, vector subtraction, and multiplying a
        vector by a scalar:
        <P><img src="img_javascript/latex_55.png"></P>
      </div>

      <div class="exercise">
<b>Exercise 2.48.</b>
        Here are two possible constructors for frames:
        <form name="form_634" style="margin-bottom: 0"><img style="padding:3mm;border:none" src="img_javascript/javascript_noeval_634.png"></form>

        For each constructor supply the appropriate selectors to produce an
        implementation for frames.
        <a name="ex:implement-frames"></a>
      </div>

      <H4>Painters</H4>
        
      

      
      <div class="normaltext">
        A painter is represented as a
        function
        that, given a frame
        as argument, draws a particular image shifted and scaled to fit the frame.
        That is to say, if <span class="javascriptinline">p</span> is a painter and <span class="javascriptinline">f</span> is a frame, then we
        produce <span class="javascriptinline">p</span>&#146;s image in <span class="javascriptinline">f</span> by calling <span class="javascriptinline">p</span> with <span class="javascriptinline">f</span> as
        argument.
      </div>

      <div class="normaltext">
        The details of how primitive painters are implemented depend on the
        particular characteristics of the graphics system and the type of
        image to be drawn.  For instance, suppose we have a
        function

        
        <span class="javascriptinline">draw_line</span> that draws a line on the screen between two specified
        points.  Then we can create painters for line drawings, such as the
        <span class="javascriptinline">wave</span> painter in figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:wave">2.10</a>, from lists of line
        segments as follows:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_22"><a class="link" href="#footnote_22">22</a></a></span>

        

        <div style="position:absolute;display:none;" id="javascript_636_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction start_segment(segment) {\n   return head(segment);\n}\nfunction end_segment(segment) {\n   return tail(segment);\n}\n            \n// for_each to be defined by the student\n          \nfunction segments_to_painter(segment_list) {\n   return function(frame) {\n             return for_each(function(segment) {\n                                return draw_line(frame_coord_map(frame)(start_segment(segment)),\n                                                 frame_coord_map(frame)(end_segment(segment)));\n                             },\n                             segment_list);\n          };\n}','javascript_636','svg()',event,1.0);">function segments_to_painter(segment_list) {
   return function(frame) {
             return for_each(function(segment) {
                                return draw_line(frame_coord_map(frame)(start_segment(segment)),
                                                 frame_coord_map(frame)(end_segment(segment)));
                             },
                             segment_list);
          };
}</pre>
      </div>

      <div class="normaltext">
        The segments are given using coordinates with respect to the unit
        square.  For each segment in the list, the painter transforms the
        segment endpoints with the frame coordinate map and draws a line
        between the transformed points.
      </div>

      <div class="normaltext">
        Representing painters as
        functions
        erects a powerful abstraction
        barrier in the picture language.  We can create and intermix
        all sorts of primitive painters, based on a variety of graphics
        capabilities. The details of their implementation do not matter.  Any
        function
        can serve as a painter, provided that it takes a frame as
        argument and draws something scaled to fit the 
        frame.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_23"><a class="link" href="#footnote_23">23</a></a></span>
      </div>

      <div class="exercise">
<b>Exercise 2.49.</b>
        
        A directed line segment in the
        plane can be represented as a pair of vectors—the
        vector running from the origin to the start-point of the segment, and
        the vector running from the origin to the end-point of the segment.
        Use your vector representation from exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:vectors">2.47</a> to
        define a representation for segments with a constructor 
        
        <span class="javascriptinline">make_segment</span> and selectors 
        
        <span class="javascriptinline">start_segment</span> and 
        
        <span class="javascriptinline">end_segment</span>.
        <a name="ex:segments2"></a>
    <div style="position:absolute;display:none;" id="javascript_637_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.50.</b>
        Use <span class="javascriptinline">segments_to_painter</span> to define the following primitive painters:

        <ol class="exercise">
          <li>
            The painter that draws the outline of the designated frame.
          </li>

          <li>
            The painter that draws an &#147;X&#148; by connecting opposite corners of
            the frame.
          </li>

          <li>
            The painter that draws a diamond shape by connecting the midpoints of
            the sides of the frame.
          </li>

          <li>
            The <span class="javascriptinline">wave</span> painter.
          </li>
        </ol>
        <a name="ex:making-wave"></a>
      </div>

      <H4>Transforming and combining painters</H4>
        
      

      

      <div class="normaltext">
        An operation on painters (such as <span class="javascriptinline">flip_vert</span> or <span class="javascriptinline">beside</span>)
        works by creating a painter that invokes the original painters
        with respect to frames derived from the argument frame.
        Thus, for example, <span class="javascriptinline">flip_vert</span> doesn&#146;t have to know how a painter
        works in order to flip it—it just has to know how to turn a frame
        upside down:
        The flipped painter just uses the original painter,
        but in the inverted frame.
      </div>

      <div class="normaltext">
        Painter operations are based on the
        function
        <span class="javascriptinline">transform_painter</span>, which takes as arguments a painter and
        information on how to transform a frame and
        produces a new painter.  The transformed painter, when called on a frame,
        transforms the frame and
        calls the original painter on the transformed frame.
        The arguments to <span class="javascriptinline">transform_painter</span> are points (represented as vectors)
        that specify the corners of the new frame:
        When mapped into
        the frame, the first point specifies the new frame&#146;s origin
        and the other two specify the ends of its edge vectors.
        Thus, arguments within the
        unit square specify a frame contained within the original frame.

        <div style="position:absolute;display:none;" id="javascript_638_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}','javascript_638','svg()',event,1.0);">function transform_painter(painter,origin,corner1,corner2) {
   return function(frame) {
             var m = frame_coord_map(frame);
             var new_origin = m(origin);
             return painter(make_frame(new_origin,
                                       sub_vect(m(corner1),new_origin),
                                       sub_vect(m(corner2),new_origin)));
          };
}</pre>

        Here&#146;s how to flip painter images vertically:
        <div style="position:absolute;display:none;" id="javascript_639_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction flip_vert(painter) {\n   return transform_painter(painter,\n                            make_vect(0.0,1.0),  // new origin\n                            make_vect(1.0,1.0),  // new end of edge1\n                            make_vect(0.0,0.0)); // new end of edge2\n}','javascript_639','svg()',event,1.0);">function flip_vert(painter) {
   return transform_painter(painter,
                            make_vect(0.0,1.0),  // new origin
                            make_vect(1.0,1.0),  // new end of edge1
                            make_vect(0.0,0.0)); // new end of edge2
}</pre>
      </div>

      <div class="normaltext">
        Using <span class="javascriptinline">transform_painter</span>, we can easily define new transformations.
        For example, we can define a painter that shrinks its image to the
        upper-right quarter of the frame it is given:
        <div style="position:absolute;display:none;" id="javascript_640_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction shrink_to_upper_right(painter) {\n   return transform_painter(painter,\n                            make_vect(0.5,0.5),\n                            make_vect(1.0,0.5),\n                            make_vect(0.5,1.0));\n}','javascript_640','svg()',event,1.0);">function shrink_to_upper_right(painter) {
   return transform_painter(painter,
                            make_vect(0.5,0.5),
                            make_vect(1.0,0.5),
                            make_vect(0.5,1.0));
}</pre>
        Other transformations rotate images counterclockwise by 90 degrees<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_24"><a class="link" href="#footnote_24">24</a></a></span>

        <div style="position:absolute;display:none;" id="javascript_641_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction rotate90(painter) {\n   return transform_painter(painter,\n                            make_vect(1.0,0.0),\n                            make_vect(1.0,1.0),\n                            make_vect(0.0,0.0));\n}','javascript_641','svg()',event,1.0);">function rotate90(painter) {
   return transform_painter(painter,
                            make_vect(1.0,0.0),
                            make_vect(1.0,1.0),
                            make_vect(0.0,0.0));
}</pre>
        or squash images towards the center of the frame:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_25"><a class="link" href="#footnote_25">25</a></a></span>

        <div style="position:absolute;display:none;" id="javascript_642_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction squash_inwards(painter) {\n   return transform_painter(painter,\n                            make_vect(0.0,0.0),\n                            make_vect(0.65,0.35),\n                            make_vect(0.35,0.65));\n}','javascript_642','svg()',event,1.0);">function squash_inwards(painter) {
   return transform_painter(painter,
                            make_vect(0.0,0.0),
                            make_vect(0.65,0.35),
                            make_vect(0.35,0.65));
}</pre>
      </div>

      <div class="normaltext">
        Frame transformation is also the key to
        defining means of combining two or more painters.
        The <span class="javascriptinline">beside</span>
        function,
        for example, takes two painters, transforms them
        to paint in the left and right halves of an argument frame respectively,
        and produces a new, compound painter.
        When the compound painter is given a frame, it
        calls the first transformed painter to paint in the left half of
        the frame and calls the second transformed painter to paint in the
        right half of the frame:
        <div style="position:absolute;display:none;" id="javascript_643_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}','javascript_643','svg()',event,1.0);">function beside(painter1,painter2) {
   var split_point = make_vect(0.5,0.0);
   var paint_left =
          transform_painter(painter1,
                            make_vect(0.0,0.0),
                            split_point,
                            make_vect(0.0,1.0));
   var paint_right =
          transform_painter(painter2,
                            split_point,
                            make_vect(1.0,0.0),
                            make_vect(0.5,1.0));
   return function(frame) {
             paint_left(frame);
             paint_right(frame);
          };
}</pre>
      </div>

      <div class="normaltext">
        Observe how the painter data abstraction, and in particular the
        representation of painters as
        functions, makes <span class="javascriptinline">beside</span> easy to
        implement.  The <span class="javascriptinline">beside</span>
        function
        need not know anything
        about the details of the component painters other than that each
        painter will draw something in its designated frame.
      </div>

      <div class="exercise">
<b>Exercise 2.51.</b>
        Define the transformation 
        
        <span class="javascriptinline">flip_horiz</span>, which flips
        painters horizontally, and transformations that rotate
        painters counterclockwise by 180 degrees and 270 degrees.
        <a name="ex:rotate"></a>

        

        

      </div>

      <div class="exercise">
<b>Exercise 2.52.</b>
        Define the 
        
        <span class="javascriptinline">below</span> operation for painters.  The function <span class="javascriptinline">below</span> takes two
        painters as arguments.  The resulting painter, given a frame,
        draws with the first painter in the
        bottom of the frame and with the second painter in the top.  Define <span class="javascriptinline">below</span> in two different ways—first by writing a
        function
        that is
        analogous to the <span class="javascriptinline">beside</span>
        function
        given above, and
        again in terms of <span class="javascriptinline">beside</span> and suitable
        rotation operations (from exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:rotate">2.51</a>).
        <a name="ex:below"></a>
        
      </div>

      <H4>Levels of language for robust design</H4>
        
      

      <div class="normaltext">
      The picture language exercises some of the critical ideas
      we&#146;ve introduced about abstraction with
      functions
      and data.  The
      fundamental data abstractions, painters, are implemented using
        
            functional
          
      representations, which enables the language to
      handle different basic drawing capabilities in a uniform way.  The
      means of combination satisfy the closure property, which permits us to
      easily build up complex designs.  Finally, all the tools for
      abstracting
      functions
      are available to us for abstracting means of
      combination for painters.
      </div>

      <div class="normaltext">
      We have also obtained a glimpse of another crucial idea about
      languages and program design.  This is the approach of 
      
      
      <em>stratified
        design</em>, the notion that a complex system should be structured as a
      sequence of levels that are described using a sequence of languages.
      Each level is constructed by combining parts that are regarded as
      primitive at that level, and the parts constructed at each level are
      used as primitives at the next level.  The language used at each level
      of a stratified design has primitives, means of combination, and means
      of abstraction appropriate to that level of detail.
      </div>

      <div class="normaltext">
      Stratified design pervades the engineering of complex systems.  For
      example, in computer engineering, resistors and transistors are
      combined (and described using a language of analog circuits) to
      produce parts such as and-gates and or-gates, which form the
      primitives of a language for digital-circuit design.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_26"><a class="link" href="#footnote_26">26</a></a></span>
      These parts are combined to build
      processors, bus structures, and memory systems, which are in turn
      combined to form computers, using languages appropriate to computer
      architecture.  Computers are combined to form distributed systems,
      using languages appropriate for describing network interconnections,
      and so on.
      </div>

      <div class="normaltext">
      As a tiny example of stratification, our picture language uses
      primitive elements (primitive painters) that are created using a
      language that specifies points and lines to provide the lists of line
      segments for <span class="javascriptinline">segments_to_painter</span>, or the
      shading details for a painter like <span class="javascriptinline">rogers</span>.  The bulk of our
      description of the picture language focused on combining these
      primitives, using geometric combiners such as <span class="javascriptinline">beside</span> and <span class="javascriptinline">below</span>.  We also worked at a higher level, regarding <span class="javascriptinline">beside</span> and
      <span class="javascriptinline">below</span> as primitives to be manipulated in a language whose
      operations, such as <span class="javascriptinline">square_of_four</span>, capture common patterns of
      combining geometric combiners.
      </div>

      <div class="normaltext">
      
      Stratified design helps make programs <em>robust</em>, that is, it makes
      it likely that small changes in a specification will require
      correspondingly small changes in the program.  For instance, suppose
      we wanted to change the image based on <span class="javascriptinline">wave</span> shown in
      figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:sqlimit-designs">2.9</a>.  We could work at the lowest level
      to change the detailed appearance of the <span class="javascriptinline">wave</span> element; we could
      work at the middle level to change the way <span class="javascriptinline">corner_split</span>
      replicates the <span class="javascriptinline">wave</span>; we could work at the highest level to
      change how <span class="javascriptinline">square_limit</span> arranges the four copies of the corner.
      In general, each level of a stratified design provides a different
      vocabulary for expressing the characteristics of the system, and a
      different kind of ability to change it.
      </div>

      <div class="exercise">
<b>Exercise 2.53.</b>
        Make changes to the square limit of <span class="javascriptinline">wave</span> shown in
        figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:sqlimit-designs">2.9</a> by working at each of the levels
        described above.  In particular:

        <ol class="exercise">
          <li>
            Add some segments to the primitive <span class="javascriptinline">wave</span> painter
            of exercise &nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:making-wave">2.50</a> (to add a smile, for example).
          </li>
          <li>
            Change the pattern constructed by <span class="javascriptinline">corner_split</span>
            (for example, by using only one copy of the
            <span class="javascriptinline">up_split</span> and <span class="javascriptinline">right_split</span> images instead of two).
          </li>
          <li>
            Modify the version of <span class="javascriptinline">square_limit</span> that uses 
            <span class="javascriptinline">square_of_four</span>
            so as to assemble the corners in a different pattern.  (For example, you
            might make the big Mr. Rogers look outward from each corner of the square.)
          </li>
        </ol>
      </div>
      

    

  <div class="navbar" align="center">
<hr>
<a class="link" onclick="window.displayManager.show('section_2_1.html')">previous section</a>&nbsp;&nbsp;&nbsp;<a class="link" onclick="window.displayManager.show('chapter_2.html')">this chapter</a>&nbsp;&nbsp;&nbsp;<a class="link" onclick="window.displayManager.show('section_2_3.html')">next section</a><hr>
</div><strong class="footnote">Footnotes</strong><div class="footnote">
<a name="footnote_1"><sup><a class="link" href="#footnote_origin_1">1</a></sup></a>The use of the word 
        
        &#147;closure&#148; here comes from abstract algebra,
        where a set of elements is said to be closed under an operation if
        applying the operation to elements in the set produces an element that
        is again an element of the set.  The Lisp community
        also (unfortunately) uses the word &#147;closure&#148; to describe a totally unrelated
        concept: A closure is an implementation technique for representing
        functions
        with free variables.  We do not use the word &#147;closure&#148; in
        this second sense in this book.</div><div class="footnote">
<a name="footnote_2"><sup><a class="link" href="#footnote_origin_2">2</a></sup></a>The notion that a means of
        
        combination should satisfy closure is a straightforward idea.
        Unfortunately, the data combiners provided in many popular programming
        languages do not satisfy closure, or make closure cumbersome to
        exploit.  In 
        
        Fortran or 
        
        Basic, one typically combines data elements by
        assembling them into arrays—but one cannot form arrays whose
        elements are themselves arrays.  
        
        Pascal and 
        
        C admit structures whose
        elements are structures.  However, this requires that the programmer
        manipulate pointers explicitly, and adhere to the restriction that
        each field of a structure can contain only elements of a prespecified form.
        Unlike
        Lisp with its pairs, these languages have no built-in general-purpose
        glue that makes it easy to manipulate compound data in a uniform way.
        This limitation lies behind Alan 
        
        Perlis&#146;s comment in his foreword to
        this book: &#147;In Pascal the plethora of declarable data structures
          induces a specialization within functions that inhibits and penalizes
          casual cooperation.  It is better to have 100 functions operate on one
          data structure than to have 10 functions operate on 10 data
          structures.&#148;</div><div class="footnote">
<a name="footnote_3"><sup><a class="link" href="#footnote_origin_3">3</a></sup></a>In this book, we use <em>list</em> to mean a chain of
          pairs terminated by the end-of-list marker.  In contrast, the term
          
          
          <em>list structure</em> refers to any data structure made out of pairs,
          not just to lists.</div><div class="footnote">
<a name="footnote_7"><sup><a class="link" href="#footnote_origin_7">7</a></sup></a><a name="foot:generalmap"></a>Our JavaScript environment provides a 
          
          <span class="schemeinline">map</span>
          function
          that is more general
          than the one described here.
          This more general <span class="schemeinline">map</span>
          takes a
          function
          of <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_696.png"></span> arguments, together with <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_697.png"></span> lists, and
          applies the
          function
          to all the first elements of
          the lists, all the second elements of the lists, and so on,
          returning a list of the results.  For example:
        <div style="position:absolute;display:none;" id="javascript_450_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction map() {\n   if (is_empty_list(arguments[1])) return [];\n   else {\n      var f = arguments[0];\n      var f_args = [];\n      var map_args = [f];\n      for (var i=1; i &lt; arguments.length; i++) {\n          f_args[i-1] = head(arguments[i]);\n          map_args[i] = tail(arguments[i]);\n      }\n      return pair(apply(f,f_args),apply(map,map_args));\n   }\n}\n          \nfunction plus() {\n   var result = 0;\n   for (var i=0; i &lt; arguments.length; i++)\n      result = result + arguments[i];\n   return result;\n}\n          \nmap(plus,\n    list(1,2,3),\n    list(40,50,60),\n    list(700,800,900))','javascript_450','',event,1.0);">map(plus,
    list(1,2,3),
    list(40,50,60),
    list(700,800,900))</pre>

<span style="color:black" title="">
          
</span>

        
        

        <div style="position:absolute;display:none;" id="javascript_453_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction map() {\n   if (is_empty_list(arguments[1])) return [];\n   else {\n      var f = arguments[0];\n      var f_args = [];\n      var map_args = [f];\n      for (var i=1; i &lt; arguments.length; i++) {\n          f_args[i-1] = head(arguments[i]);\n          map_args[i] = tail(arguments[i]);\n      }\n      return pair(apply(f,f_args),apply(map,map_args));\n   }\n}\n          \nmap(function(x,y) { return x + 2 * y; },\n    list(1,2,3),\n    list(4,5,6))','javascript_453','',event,1.0);">map(function(x,y) { return x + 2 * y; },
    list(1,2,3),
    list(4,5,6))</pre>
        </div><div class="footnote">
<a name="footnote_8"><sup><a class="link" href="#footnote_origin_8">8</a></sup></a>The order of the
          first two clauses in the <span class="schemeinline">cond</span> matters, since the empty list
          satisfies <span class="schemeinline">null?</span> and also is not a pair.</div><div class="footnote">
<a name="footnote_9"><sup><a class="link" href="#footnote_origin_9">9</a></sup></a>This 
          is, in fact, precisely the 
          
          <span class="javascriptinline">fringe</span>
          function
          from
          exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:fringe">2.29</a>.  Here we&#146;ve renamed it to emphasize that
          it is part of a family of general sequence-manipulation
          functions.</div><div class="footnote">
<a name="footnote_10"><sup><a class="link" href="#footnote_origin_10">10</a></sup></a>
          
          Richard Waters (1979)
          developed a program that automatically analyzes traditional 
          
          Fortran
          programs, viewing them in terms of maps, filters, and accumulations.
          He found that fully 90 percent of the code in the Fortran Scientific
          Subroutine Package fits neatly into this paradigm.  One of the reasons
          for the success of Lisp as a programming language is that lists
          provide a standard medium for expressing ordered collections so that
          they can be manipulated using higher-order operations.  The
          programming language 
          
          APL owes much of its power and appeal to a
          similar choice. In APL all data are represented as arrays, and there is a
          universal and convenient set of generic operators for all sorts of
          array operations.</div><div class="footnote">
<a name="footnote_11"><sup><a class="link" href="#footnote_origin_11">11</a></sup></a>According to 
          
          Knuth (1981), this rule was formulated by
          
          W. G. Horner early in the nineteenth century, but the method was
          actually used by Newton over a hundred years earlier.  Horner&#146;s rule
          evaluates the polynomial using fewer additions and multiplications
          than does the straightforward method of first computing <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_711.png"></span>,
          then adding <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_712.png"></span>, and so on.  In fact, it is possible to
          prove that any algorithm for evaluating arbitrary polynomials must use
          at least as many additions and multiplications as does Horner&#146;s rule,
          and thus Horner&#146;s rule is an 
          
          
          optimal algorithm for polynomial
          evaluation.  This was proved (for the number of additions) by
          
          A. M. Ostrowski in a 1954 paper that essentially founded the modern
          study of optimal algorithms.  The analogous statement for
          multiplications was proved by 
          
          V. Y. Pan in 1966.  The book by 
          
          
          Borodin and Munro (1975) 
          provides an overview of these and other results about
          optimal algorithms.</div><div class="footnote">
<a name="footnote_12"><sup><a class="link" href="#footnote_origin_12">12</a></sup></a>This definition uses the
          extended version of <span class="javascriptinline">map</span> described in footnote&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#foot:generalmap">7 of Section 2.2</a>.</div><div class="footnote">
<a name="footnote_13"><sup><a class="link" href="#footnote_origin_13">13</a></sup></a>This approach to nested mappings was shown
          to us by 
          
          David Turner, whose languages 
          
          KRC and 
          
          Miranda provide elegant
          formalisms for dealing with these constructs.  The examples in this
          section (see also exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:8queens">2.43</a>) are adapted from Turner
          1981.  In section&nbsp;, we&#146;ll see how this
          approach generalizes to infinite sequences.</div><div class="footnote">
<a name="footnote_14"><sup><a class="link" href="#footnote_origin_14">14</a></sup></a>We&#146;re
          representing a pair here as a list of two elements rather than as
          an ordinary pair.  Thus, the &#147;pair&#148; <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_756.png"></span> is represented as <span class="javascriptinline">list(i,j)</span>, not <span class="javascriptinline">pair(i,j)</span>.</div><div class="footnote">
<a name="footnote_15"><sup><a class="link" href="#footnote_origin_15">15</a></sup></a>The set <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_769.png"></span> is the set of all elements
          of <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_770.png"></span>, excluding <span style="vertical-align:-2.0pt"><img src="img_javascript/latex_inline_footnote_771.png"></span>.</div><div class="footnote">
<a name="footnote_16"><sup><a class="link" href="#footnote_origin_16">16</a></sup></a>
          
          
          
          The character sequence <span class="javascriptinline">//</span> in JavaScript code is used to
          introduce <em>comments</em>.  Everything from <span class="javascriptinline">//</span> to the end of
          the line is ignored by the interpreter.  In this book we don&#146;t use
          many comments; we try to make our programs self-documenting by using
          descriptive names.</div><div class="footnote">
<a name="footnote_17"><sup><a class="link" href="#footnote_origin_17">17</a></sup></a>The picture language is based on the language
          
          Peter Henderson created to construct
          images like 
          
          M.C. Escher&#146;s &#147;Square Limit&#148; woodcut (see Henderson 1982).
          The woodcut incorporates a
          repeated scaled pattern, similar to the arrangements drawn using
          the <span class="javascriptinline">square_limit</span>
          function
          in this section.</div><div class="footnote">
<a name="footnote_18"><sup><a class="link" href="#footnote_origin_18">18</a></sup></a>
            
            
            William Barton Rogers (1804–1882) was the founder and first president
            of MIT.  A geologist and talented teacher, he taught at William and
            Mary College and at the University of Virginia.  In 1859 he moved to
            Boston, where he had more time for research, worked on a plan
            for establishing a &#147;polytechnic institute,&#148; and served as
            Massachusetts&#146;s first State Inspector of Gas Meters.
          <p>
            When MIT was established in 1861, Rogers was elected its first
            president.  Rogers espoused an ideal of &#147;useful learning&#148; that was
            different from the university education of the time, with its
            overemphasis on the classics, which, as he wrote, &#147;stand in the way of
              the broader, higher and more practical instruction and discipline of
              the natural and social sciences.&#148;  This education was likewise to be
            different from narrow trade-school education.  In Rogers&#146;s words:
            <blockquote>
              The world-enforced distinction between the practical and the
              scientific worker is utterly futile, and the whole experience of
              modern times has demonstrated its utter worthlessness.
            </blockquote>
          </p>
          <p>
            Rogers served as president of MIT until 1870, when he resigned due to
            ill health.  In 1878 the second president of MIT, 
            
            John Runkle,
            resigned under the pressure of a financial crisis brought on by the
            Panic of 1873 and strain of fighting off attempts by Harvard to take
            over MIT.  Rogers returned to hold the office of president until
            1881.
          </p>
          <p>
            Rogers collapsed and died while addressing MIT&#146;s graduating class at
            the commencement exercises of 1882.  Runkle quoted Rogers&#146;s last
            words in a memorial address delivered that same year:
            <blockquote>
                &#147;As I stand here today and see what the Institute is, &#8230;&nbsp;I call
                  to mind the beginnings of science.  I remember one hundred and fifty
                  years ago Stephen Hales published a pamphlet on the subject of
                  illuminating gas, in which he stated that his researches had
                  demonstrated that 128 grains of bituminous coal—&#148;
              <p>
              
              &#147;Bituminous coal,&#148; these were his last words on earth.  Here he bent
                forward, as if consulting some notes on the table before him, then
                slowly regaining an erect position, threw up his hands, and was
                translated from the scene of his earthly labors and triumphs to &#147;the
                  tomorrow of death,&#148; where the mysteries of life are solved, and the
                disembodied spirit finds unending satisfaction in contemplating the
                new and still unfathomable mysteries of the infinite future.
              </p>
            </blockquote>
          </p>
          <p>
            In the words of  Francis A. Walker
            
            (MIT&#146;s third president):
            <blockquote>
              All his life he had borne himself most faithfully and heroically, and
              he died as so good a knight would surely have wished, in harness, at
              his post, and in the very part and act of public duty.
            </blockquote>
          </p>
        </div><div class="footnote">
<a name="footnote_19"><sup><a class="link" href="#footnote_origin_19">19</a></sup></a>Equivalently, we could
          write
          <div style="position:absolute;display:none;" id="javascript_622_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction beside(painter1,painter2) {\n   var split_point = make_vect(0.5,0.0);\n   var paint_left =\n          transform_painter(painter1,\n                            make_vect(0.0,0.0),\n                            split_point,\n                            make_vect(0.0,1.0));\n   var paint_right =\n          transform_painter(painter2,\n                            split_point,\n                            make_vect(1.0,0.0),\n                            make_vect(0.5,1.0));\n   return function(frame) {\n             paint_left(frame);\n             paint_right(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction below(painter1,painter2) {\n   var split_point = make_vect(0.0,0.5);\n   var paint_upper =\n          transform_painter(painter1,\n                            split_point,\n                            make_vect(1.0,0.5),\n                            make_vect(0.0,1.0));\n   var paint_lower =\n          transform_painter(painter2,\n                            make_vect(0.0,0.0),\n                            make_vect(1.0,0.0),\n                            split_point);\n   return function(frame) {\n             paint_upper(frame);\n             paint_lower(frame);\n          };\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction square_of_four(tl,tr,bl,br) {\n   return function(painter) {\n             var top = beside(tl(painter),tr(painter));\n             var bottom = beside(bl(painter),br(painter));\n             return below(bottom,top);\n          }\n}\n          \nfunction identity(x) {\n   return x;\n}\n          \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction frame_coord_map(frame) {\n   return function(v) {\n             return add_vect(origin_frame(frame),\n                             add_vect(scale_vect(xcor_vect(v),\n                                                 edge1_frame(frame)),\n                                      scale_vect(ycor_vect(v),\n                                                 edge2_frame(frame))));\n          };\n}\n          \nfunction transform_painter(painter,origin,corner1,corner2) {\n   return function(frame) {\n             var m = frame_coord_map(frame);\n             var new_origin = m(origin);\n             return painter(make_frame(new_origin,\n                                       sub_vect(m(corner1),new_origin),\n                                       sub_vect(m(corner2),new_origin)));\n          };\n}\n          \nfunction flip_vert(painter) {\n   return transform_painter(painter,\n                            make_vect(0.0,1.0),  // new origin\n                            make_vect(1.0,1.0),  // new end of edge1\n                            make_vect(0.0,0.0)); // new end of edge2\n}\n        \nvar rogers = make_painter_from_url(\n           &quot;http://www.comp.nus.edu.sg/~henz/sicp/img_original/ch2-Z-G-30.gif&quot;);\n              \nfunction list_ref(items,n) {\n   if (n === 0)\n      return head(items);\n   else return list_ref(tail(items),n - 1);\n}\n          \nfunction make_frame(origin,edge1,edge2) {\n   return list(origin,edge1,edge2);\n}\nfunction origin_frame(frame) {\n   return list_ref(frame,0);\n}\nfunction edge1_frame(frame) {\n   return list_ref(frame,1);\n}\nfunction edge2_frame(frame) {\n   return list_ref(frame,2);\n}\n            \nfunction make_vect(x,y) {\n   return pair(x,y);\n}\nfunction xcor_vect(vector) {\n   return head(vector);\n}\nfunction ycor_vect(vector) {\n   return tail(vector);\n}\nfunction scale_vect(factor,vector) {\n   return make_vect(factor * xcor_vect(vector), \n                    factor * ycor_vect(vector));\n}\nfunction add_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) + xcor_vect(vector2), \n                    ycor_vect(vector1) + ycor_vect(vector2));\n}\nfunction sub_vect(vector1,vector2) {\n   return make_vect(xcor_vect(vector1) - xcor_vect(vector2), \n                    ycor_vect(vector1) - ycor_vect(vector2));\n}\n            \nvar full_frame = make_frame(make_vect(0,0),\n                            make_vect(1,0),\n                            make_vect(0,1));\n              \nvar flipped_pairs = \n    square_of_four(identity,flip_vert,identity,flip_vert);\n\n// example\n\nflipped_pairs(rogers)(full_frame);','javascript_622','svg()',event,1.0);">var flipped_pairs = 
    square_of_four(identity,flip_vert,identity,flip_vert);</pre>
        </div><div class="footnote">
<a name="footnote_20"><sup><a class="link" href="#footnote_origin_20">20</a></sup></a>The function <span class="javascriptinline">rotate180</span>
          rotates a painter by 180 degrees (see exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:rotate">2.51</a>).
          Instead of <span class="javascriptinline">rotate180</span> we could say <span class="javascriptinline">compose(flip_vert,flip_horiz)</span>, using
          the <span class="javascriptinline">compose</span>
          function
          from exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_1_3.html')" href="#ex:compose">1.43</a>.</div><div class="footnote">
<a name="footnote_21"><sup><a class="link" href="#footnote_origin_21">21</a></sup></a>The function <span class="javascriptinline">frame_coord_map</span> uses
          the vector operations described in exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:vectors">2.47</a> below, which we
          assume have been implemented using some representation for vectors.
          Because of data abstraction, it doesn&#146;t matter what this vector
          representation is, so long as the vector operations behave correctly.</div><div class="footnote">
<a name="footnote_22"><sup><a class="link" href="#footnote_origin_22">22</a></sup></a>The function <span class="javascriptinline">segments_to_painter</span> uses the representation for line
          segments described in exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:segments2">2.49</a> below.
          It also uses the <span class="javascriptinline">for_each</span>
          function
          described in exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#ex:for-each">2.24</a>.</div><div class="footnote">
<a name="footnote_23"><sup><a class="link" href="#footnote_origin_23">23</a></sup></a>For example, the <span class="javascriptinline">rogers</span> painter of
          figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:rogers">2.11</a> was constructed from a gray-level image.
          For each point in a given frame,
          the <span class="schemeinline">rogers</span> painter determines the point in the image that is mapped to it
          under the frame coordinate map, and shades it
          accordingly.  By allowing different types of painters, we are capitalizing on the
          abstract data idea discussed in section&nbsp;<a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#sec:data?">2.1.3</a>, where we
          argued that a rational-number representation could be anything at all that
          satisfies an appropriate condition.  Here we&#146;re using the fact that a
          painter can be implemented in any way at all, so long as it draws
          something in the designated frame.  Section&nbsp;<a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#sec:data?">2.1.3</a> also
          showed how pairs could be implemented as
          functions.  Painters are our
          second example of a 
        
            functional
          
          representation for data.</div><div class="footnote">
<a name="footnote_24"><sup><a class="link" href="#footnote_origin_24">24</a></sup></a>The function <span class="javascriptinline">rotate90</span> is a pure rotation only for square
          frames, because it also stretches and shrinks the image to fit into
          the rotated frame.</div><div class="footnote">
<a name="footnote_25"><sup><a class="link" href="#footnote_origin_25">25</a></sup></a>The diamond-shaped images in figures&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:wave">2.10</a>
          and&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')" href="#fig:rogers">2.11</a> were created with <span class="javascriptinline">squash_inwards</span> applied to
          <span class="javascriptinline">wave</span> and <span class="javascriptinline">rogers</span>.</div><div class="footnote">
<a name="footnote_26"><sup><a class="link" href="#footnote_origin_26">26</a></sup></a>Section&nbsp; describes one such language.</div>

<div class="navbar" align="center">&nbsp;&nbsp;&nbsp;<a class="link" onclick="window.displayManager.show('chapter_2.html')">this chapter</a>&nbsp;&nbsp;&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')">next section</a><hr>
</div><h2><a name="section_2_1">2.1&nbsp;Introduction to Data Abstraction</a></h2>
    

    <div class="subtoc">
<strong>In this section</strong><p></p>
<a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#subsection_2_1_1">2.1.1&nbsp;
        Example: Arithmetic Operations for Rational Numbers
      </a><br><a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#subsection_2_1_2">2.1.2&nbsp;
        Abstraction Barriers
      </a><br><a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#subsection_2_1_3">2.1.3&nbsp;
        What Is Meant by Data?
      </a><br><a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#subsection_2_1_4">2.1.4&nbsp;
        Extended Exercise: Interval Arithmetic
      </a><br>
</div>

    <a name="sec:data-abstraction"></a>

    <div class="normaltext">
      In section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_1.html')" href="#sec:black-box">1.1.8</a>, we noted
      that a
      function
      used as an element in creating a more complex
      function
      could be regarded not only as a collection of particular
      operations but also as a 
      functional
      abstraction.  That is, the details
      of how the
      function
      was implemented could be suppressed, and the
      particular
      function
      itself could be replaced by any other
      function
      with the same overall behavior.  In other words, we could make an
      abstraction that would separate the way the
      function
      would be used
      from the details of how the
      function
      would be implemented in terms of
      more primitive
      functions.  The analogous notion for compound data is
      called 
      
      <em>data abstraction</em>.  Data abstraction is a methodology that
      enables us to isolate how a compound data object is used from the
      details of how it is constructed from more primitive data objects.
    </div>

    <div class="normaltext">
      The basic idea of data abstraction is to structure the programs that
      are to use compound data objects so that they operate on 
      
      
      &#147;abstract
        data.&#148; That is, our programs should use data in such a way as to make
      no assumptions about the data that are not strictly necessary for
      performing the task at hand.  At the same time, a 
      
      
      &#147;concrete&#148; data
      representation is defined independent of the programs that use
      the data.  The interface between these two parts of our system will be
      a set of
      functions, called 
      
      <em>selectors</em> and 
      
      <em>constructors</em>,
      that implement the abstract data in terms of the concrete
      representation.  To illustrate this technique, we will consider how to
      design a set of
      functions
      for manipulating rational numbers.
    </div>

    <h3><a name="subsection_2_1_1">2.1.1&nbsp;
        Example: Arithmetic Operations for Rational Numbers
      </a></h3> 
      

      <a name="sec:rationals"></a>

      <div class="normaltext">
        
        
        
        Suppose we want to do arithmetic with rational numbers.  We want to be
        able to add, subtract, multiply, and divide them and to test whether
        two rational numbers are equal.
      </div>

      <div class="normaltext">
        Let us begin by assuming that we already have a way of constructing a
        rational number from a numerator and a denominator.  We also assume
        that, given a rational number, we have a way of extracting (or
        selecting) its numerator and its denominator.  Let us further assume
        that the constructor and selectors are available as
        functions:

        <ul>
          
          <li>
<span class="javascriptinline">make_rat(n,d)</span>
            returns the
            rational number whose  numerator is the integer <span class="schemeinline">n</span>
            and whose denominator is the integer <span class="schemeinline">d</span>. 

            
          </li>
          <li>
<span class="javascriptinline">numer(x)</span> 
            returns the numerator of the rational 
            number <span class="schemeinline">x</span>.

            
          </li>
          <li>
<span class="javascriptinline">denom(x)</span>
            returns the denominator of the 
            rational number <span class="schemeinline">x</span>.
          </li>
        </ul>
      </div>

      <div class="normaltext">
        We are using here a powerful strategy of synthesis: 
        
        <em>wishful thinking</em>.
        We haven&#146;t yet said how a rational number is represented, or how the
        functions
        <span class="schemeinline">numer</span>, 
        <span class="schemeinline">denom</span>, and 
        <span class="javascriptinline">make_rat</span>
        should be
        implemented.  Even so, if we did have these three
        functions, we could
        then add, subtract, multiply, divide, and test equality by using the
        following relations:

        <P><img src="img_javascript/latex_39.png"></P>

        <P><img src="img_javascript/latex_40.png"></P>

        <P><img src="img_javascript/latex_41.png"></P>

        <P><img src="img_javascript/latex_42.png"></P>

        <P><img src="img_javascript/latex_43.png"></P>
      </div>

      <div class="normaltext">
        We can express these rules as
        functions:

        <div style="position:absolute;display:none;" id="javascript_355_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nfunction add_rat(x,y) {\n   return make_rat(numer(x)*denom(y) + numer(y)*denom(x),\n                  denom(x) * denom(y));\n}\nfunction sub_rat(x,y) {\n   return make_rat(numer(x)*denom(y) - numer(y)*denom(x),\n                  denom(x) * denom(y));\n}\nfunction mul_rat(x,y) {\n   return make_rat(numer(x)*numer(y),\n                   denom(x)*denom(y));\n}\nfunction div_rat(x,y) {\n   return make_rat(numer(x)*denom(y),\n                   denom(x)*numer(y));\n}\nfunction equal_rat(x,y) {\n   return numer(x)*denom(y) === numer(y)*denom(x);\n}\n\n// example\n\nvar one_half = make_rat(1,2);\n\nprint_rat(one_half);','javascript_355','',event,1.0);">function add_rat(x,y) {
   return make_rat(numer(x)*denom(y) + numer(y)*denom(x),
                  denom(x) * denom(y));
}
function sub_rat(x,y) {
   return make_rat(numer(x)*denom(y) - numer(y)*denom(x),
                  denom(x) * denom(y));
}
function mul_rat(x,y) {
   return make_rat(numer(x)*numer(y),
                   denom(x)*denom(y));
}
function div_rat(x,y) {
   return make_rat(numer(x)*denom(y),
                   denom(x)*numer(y));
}
function equal_rat(x,y) {
   return numer(x)*denom(y) === numer(y)*denom(x);
}</pre>
      </div>

      <div class="normaltext">
        Now we have the operations on rational numbers defined in terms of the
        selector and constructor
        functions
        <span class="schemeinline">numer</span>, <span class="schemeinline">denom</span>, and <span class="javascriptinline">make_rat</span>.
        But we haven&#146;t yet defined these.
        What we need is some way to glue together a numerator and a
        denominator to form a rational
        number.
      </div>

      <H4>Pairs</H4>
        
      

      <div class="normaltext">
        To enable us to implement the concrete level of our data
        abstraction, our language provides a compound structure called a 
        
        <em>
          pair</em>, which can be constructed with the 
        function
        
        <span class="javascriptinline">pair</span>.  This
        function
        takes two arguments and returns a compound data
        object that contains the two arguments as parts.  Given a pair, we can
        extract the parts using the primitive
        functions
        
        <span class="javascriptinline">head</span> 
        and
        <span class="javascriptinline">tail</span>.
            These functions are not &#147;primitive&#148; functions in JavaScript. However, they are available in the programming environment used here, defined using <em>arrays</em>, one of JavaScript&#146;s primitive data structures.
        Thus, we can use <span class="javascriptinline">pair</span>, <span class="javascriptinline">head</span>, and <span class="javascriptinline">tail</span> as follows:

        <div style="position:absolute;display:none;" id="javascript_356_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = pair(1,2);\n\n// example\n\nhead(x);','javascript_356','',event,1.0);">var x = pair(1,2);</pre>

        <div style="position:absolute;display:none;" id="javascript_357_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = pair(1,2);\n          \nhead(x);','javascript_357','',event,1.0);">head(x);</pre>

        <div style="position:absolute;display:none;" id="javascript_358_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = pair(1,2);\n          \ntail(x);','javascript_358','',event,1.0);">tail(x);</pre>
      </div>

      <div class="normaltext">
        Notice that a pair is a data object that can be given a name and
        manipulated, just like a primitive data object.  Moreover, <span class="javascriptinline">pair</span>
        can be used to form pairs whose elements are pairs, and so on:

        <div style="position:absolute;display:none;" id="javascript_359_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = pair(1,2);\nvar y = pair(3,4);\nvar z = pair(x,y);\n\n// example\n\nhead(head(z));','javascript_359','',event,1.0);">var x = pair(1,2);
var y = pair(3,4);
var z = pair(x,y);</pre>

        <div style="position:absolute;display:none;" id="javascript_360_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = pair(1,2);\nvar y = pair(3,4);\nvar z = pair(x,y);\n          \nhead(head(z));','javascript_360','',event,1.0);">head(head(z));</pre>

        <div style="position:absolute;display:none;" id="javascript_361_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar x = pair(1,2);\nvar y = pair(3,4);\nvar z = pair(x,y);\n          \nhead(tail(z));','javascript_361','',event,1.0);">head(tail(z));</pre>
      </div>

      <div class="normaltext">
        In section&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')">2.2</a> we will see how this ability to
        combine pairs means that pairs can be used as general-purpose building
        blocks to create all sorts of complex data structures.  The single
        compound-data primitive <em>pair</em>, implemented by the
        functions
        <span class="javascriptinline">pair</span>, <span class="javascriptinline">head</span>, and <span class="javascriptinline">tail</span>, is the only glue we need.  Data
        objects constructed from pairs are called 
        
        
        <em>list-structured</em> data.
      </div>

      <H4>Representing rational numbers</H4>
        
      

      <div class="normaltext">
        
        Pairs offer a natural way to complete the rational-number system.
        Simply represent a rational number as a pair of two integers: a
        numerator and a denominator.  Then <span class="javascriptinline">make_rat</span>, <span class="schemeinline">numer</span>, and
        <span class="schemeinline">denom</span> are readily implemented as 
        follows:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_2"><a class="link" href="#footnote_2">2</a></a></span>

        <div style="position:absolute;display:none;" id="javascript_363_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar make_rat = pair;\nvar numer = head;\nvar denom = tail;','javascript_363','',event,1.0);">var make_rat = pair;
var numer = head;
var denom = tail;</pre>
      </div>

      <div class="normaltext">
        Also, in order to display the results of our computations,
        we can 
        
        print rational numbers by printing the numerator, a
        slash, and the denominator:<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_3"><a class="link" href="#footnote_3">3</a></a></span>

        <div style="position:absolute;display:none;" id="javascript_364_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n\n// example\n\nvar one_half = make_rat(1,2);\n\nprint_rat(one_half);','javascript_364','',event,1.0);">function print_rat(x) {
   return print(numer(x) + "/" + denom(x));
}</pre>
      </div>

      <div class="normaltext">
        Now we can try our rational-number
        functions:

        <div style="position:absolute;display:none;" id="javascript_365_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nvar one_half = make_rat(1,2);\n\nprint_rat(one_half);','javascript_365','',event,1.0);">var one_half = make_rat(1,2);

print_rat(one_half);</pre>

        

        

        <div style="position:absolute;display:none;" id="javascript_368_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nfunction add_rat(x,y) {\n   return make_rat(numer(x)*denom(y) + numer(y)*denom(x),\n                  denom(x) * denom(y));\n}\nfunction sub_rat(x,y) {\n   return make_rat(numer(x)*denom(y) - numer(y)*denom(x),\n                  denom(x) * denom(y));\n}\nfunction mul_rat(x,y) {\n   return make_rat(numer(x)*numer(y),\n                   denom(x)*denom(y));\n}\nfunction div_rat(x,y) {\n   return make_rat(numer(x)*denom(y),\n                   denom(x)*numer(y));\n}\nfunction equal_rat(x,y) {\n   return numer(x)*denom(y) === numer(y)*denom(x);\n}\n          \nvar one_half = make_rat(1,2);\n          \nvar one_third = make_rat(1,3);\n          \nprint_rat(add_rat(one_half,one_third));','javascript_368','',event,1.0);">print_rat(add_rat(one_half,one_third));</pre>

        <div style="position:absolute;display:none;" id="javascript_369_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nfunction add_rat(x,y) {\n   return make_rat(numer(x)*denom(y) + numer(y)*denom(x),\n                  denom(x) * denom(y));\n}\nfunction sub_rat(x,y) {\n   return make_rat(numer(x)*denom(y) - numer(y)*denom(x),\n                  denom(x) * denom(y));\n}\nfunction mul_rat(x,y) {\n   return make_rat(numer(x)*numer(y),\n                   denom(x)*denom(y));\n}\nfunction div_rat(x,y) {\n   return make_rat(numer(x)*denom(y),\n                   denom(x)*numer(y));\n}\nfunction equal_rat(x,y) {\n   return numer(x)*denom(y) === numer(y)*denom(x);\n}\n          \nvar one_half = make_rat(1,2);\n          \nvar one_third = make_rat(1,3);\n          \nprint_rat(mul_rat(one_half,one_third));','javascript_369','',event,1.0);">print_rat(mul_rat(one_half,one_third));</pre>

        <div style="position:absolute;display:none;" id="javascript_370_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nfunction add_rat(x,y) {\n   return make_rat(numer(x)*denom(y) + numer(y)*denom(x),\n                  denom(x) * denom(y));\n}\nfunction sub_rat(x,y) {\n   return make_rat(numer(x)*denom(y) - numer(y)*denom(x),\n                  denom(x) * denom(y));\n}\nfunction mul_rat(x,y) {\n   return make_rat(numer(x)*numer(y),\n                   denom(x)*denom(y));\n}\nfunction div_rat(x,y) {\n   return make_rat(numer(x)*denom(y),\n                   denom(x)*numer(y));\n}\nfunction equal_rat(x,y) {\n   return numer(x)*denom(y) === numer(y)*denom(x);\n}\n          \nvar one_half = make_rat(1,2);\n          \nvar one_third = make_rat(1,3);\n          \nprint_rat(div_rat(one_half,one_third));','javascript_370','',event,1.0);">print_rat(div_rat(one_half,one_third));</pre>
      </div>

      <div class="normaltext">
        
        
        As the final example shows, our rational-number implementation does
        not reduce rational numbers to lowest terms.  We can remedy this by
        changing <span class="javascriptinline">make_rat</span>. If we have a 
        
        <span class="schemeinline">gcd</span>
        function
        like the one
        in section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_2.html')" href="#sec:gcd">1.2.5</a> that produces the greatest common divisor of two
        integers, we can use <span class="schemeinline">gcd</span> to reduce the numerator and the
        denominator to lowest terms before constructing the pair:
        
        <div style="position:absolute;display:none;" id="javascript_371_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction gcd(a,b) {\n   return b === 0 ? a : gcd(b, a % b);\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nfunction add_rat(x,y) {\n   return make_rat(numer(x)*denom(y) + numer(y)*denom(x),\n                  denom(x) * denom(y));\n}\nfunction sub_rat(x,y) {\n   return make_rat(numer(x)*denom(y) - numer(y)*denom(x),\n                  denom(x) * denom(y));\n}\nfunction mul_rat(x,y) {\n   return make_rat(numer(x)*numer(y),\n                   denom(x)*denom(y));\n}\nfunction div_rat(x,y) {\n   return make_rat(numer(x)*denom(y),\n                   denom(x)*numer(y));\n}\nfunction equal_rat(x,y) {\n   return numer(x)*denom(y) === numer(y)*denom(x);\n}\n          \nvar one_third = make_rat(1,3);\n          \nfunction make_rat(n,d) {\n   var g = gcd(n,d);\n   return pair(n / g, d / g);\n}\n\n// example\n\nprint_rat(add_rat(one_third,one_third));','javascript_371','',event,1.0);">function make_rat(n,d) {
   var g = gcd(n,d);
   return pair(n / g, d / g);
}</pre>

      </div>

      <div class="normaltext">
        Now we have
        <div style="position:absolute;display:none;" id="javascript_372_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction gcd(a,b) {\n   return b === 0 ? a : gcd(b, a % b);\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nfunction add_rat(x,y) {\n   return make_rat(numer(x)*denom(y) + numer(y)*denom(x),\n                  denom(x) * denom(y));\n}\nfunction sub_rat(x,y) {\n   return make_rat(numer(x)*denom(y) - numer(y)*denom(x),\n                  denom(x) * denom(y));\n}\nfunction mul_rat(x,y) {\n   return make_rat(numer(x)*numer(y),\n                   denom(x)*denom(y));\n}\nfunction div_rat(x,y) {\n   return make_rat(numer(x)*denom(y),\n                   denom(x)*numer(y));\n}\nfunction equal_rat(x,y) {\n   return numer(x)*denom(y) === numer(y)*denom(x);\n}\n          \nvar one_third = make_rat(1,3);\n          \nfunction make_rat(n,d) {\n   var g = gcd(n,d);\n   return pair(n / g, d / g);\n}\n          \nprint_rat(add_rat(one_third,one_third));','javascript_372','',event,1.0);">print_rat(add_rat(one_third,one_third));</pre>

        as desired.  This modification was accomplished by changing the
        constructor <span class="javascriptinline">make-rat</span> without changing any of the
        functions
        (such as <span class="javascriptinline">add_rat</span> and <span class="javascriptinline">mul_rat</span>)
        that implement the actual operations.
      </div>

      <div class="exercise">
<b>Exercise 2.1.</b> 
        Define a better version of <span class="javascriptinline">make_rat</span> that
        handles both positive and negative arguments.  The function <span class="javascriptinline">make_rat</span> should
        normalize the sign so that if the rational number is positive, both
        the numerator and denominator are positive, and if the rational number
        is negative, only the numerator is negative.
    <div style="position:absolute;display:none;" id="javascript_373_div"></div>
    
      </div>
      
      
      

    

    <h3><a name="subsection_2_1_2">2.1.2&nbsp;
        Abstraction Barriers
      </a></h3>
      

      <a name="sec:abstraction-barriers"></a>

      <div class="normaltext">
        
        Before continuing with more examples of compound data and data
        abstraction, let us consider some of the issues raised by the
        rational-number example.  We defined the rational-number operations in
        terms of a constructor <span class="javascriptinline">make_rat</span> and selectors <span class="schemeinline">numer</span> and
        <span class="schemeinline">denom</span>.  In general, the underlying idea of data abstraction is
        to identify for each type of data object a basic set of operations in
        terms of which all manipulations of data objects of that type will be
        expressed, and then to use only those operations in manipulating the
        data.
      </div>

      <div class="normaltext">
        We can envision the structure of the rational-number system as
        shown in figure&nbsp;<a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#fig:abstraction-barriers">2.1</a>.  The
        horizontal lines represent <em>abstraction barriers</em> that isolate
        different &#147;levels&#148; of the system.  At each level, the barrier
        separates the programs (above) that use the data abstraction from the
        programs (below) that implement the data abstraction.  Programs that
        use rational numbers manipulate them solely in terms of the
        functions
        supplied &#147;for public use&#148; by the rational-number package: <span class="javascriptinline">add_rat</span>, <span class="javascriptinline">sub_rat</span>, <span class="javascriptinline">mul_rat</span>, <span class="javascriptinline">div_rat</span>, and <span class="javascriptinline">equal_rat</span>. These, in turn, are implemented solely in terms of the
        
        
        constructor and selectors <span class="javascriptinline">make_rat</span>, <span class="schemeinline">numer</span>, and <span class="schemeinline">denom</span>, which themselves are implemented in terms of pairs.  The
        details of how pairs are implemented are irrelevant to the rest of the
        rational-number package so long as pairs can be manipulated by the use
        of <span class="javascriptinline">pair</span>, <span class="javascriptinline">head</span>, and <span class="javascriptinline">tail</span>.  In effect,
        functions
        at
        each level are the interfaces that define the abstraction barriers and
        connect the different levels.

              <p><div align="center"><table width="100%">
<tr><td align="center">
<img src="img_original/ch2-Z-G-6.gif" border="0">
                <a name="fig:abstraction-barriers"></a>
                
              </td></tr>
<caption align="bottom"><div align="center">
<b>Figure 2.
                  1</b>&nbsp;&nbsp;&nbsp;Data-abstraction barriers in the rational-number package.
                </div></caption>
<tr><td></td></tr>
</table></div></p>
      </div>

      <div class="normaltext">
        This simple idea has many advantages.  One advantage is that it makes
        programs much easier to maintain and to modify.  Any complex data
        structure can be represented in a variety of ways with the primitive
        data structures provided by a programming language.  Of course, the
        choice of representation influences the programs that operate on it;
        thus, if the representation were to be changed at some later time, all
        such programs might have to be modified accordingly.  This task could
        be time-consuming and expensive in the case of large programs unless
        the dependence on the representation were to be confined by design to
        a very few program modules.
      </div>

      <div class="normaltext">
        
        
        For example, an alternate way to address the problem of reducing rational
        numbers to lowest terms is to perform the reduction whenever we
        access the parts of a rational number, rather than when we construct
        it.  This leads to different constructor and selector
        functions:

        <div style="position:absolute;display:none;" id="javascript_375_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}\n          \nfunction print_rat(x) {\n   return print(numer(x) + &quot;/&quot; + denom(x));\n}\n          \nfunction gcd(a,b) {\n   return b === 0 ? a : gcd(b, a % b);\n}\n          \nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   var g = gcd(head(x),tail(x));\n   return head(x) / g;\n}\nfunction denom(x) {\n   var g = gcd(head(x),tail(x));\n   return tail(x) / g;\n}\n\n// example\n\nvar one_half = make_rat(1,2);\n\nprint_rat(one_half);','javascript_375','',event,1.0);">function make_rat(n,d) {
   return pair(n,d);
}
function numer(x) {
   var g = gcd(head(x),tail(x));
   return head(x) / g;
}
function denom(x) {
   var g = gcd(head(x),tail(x));
   return tail(x) / g;
}</pre>
      </div>

      <div class="normaltext">
        The difference between this implementation and the previous one lies
        in when we compute the <span class="schemeinline">gcd</span>.
        If in our typical use of rational numbers we access the
        numerators and denominators of the same rational numbers many
        times, it would be preferable
        to compute the <span class="schemeinline">gcd</span> when the rational numbers are constructed.
        If not, we may be better off waiting until access
        time to compute the <span class="schemeinline">gcd</span>.  In any case, when
        we change from one representation to the other, the
        functions
        <span class="javascriptinline">add_rat</span>, <span class="javascriptinline">sub_rat</span>, and so on do not have to be modified at all.
      </div>

      <div class="normaltext">
        Constraining the dependence on the representation to a few interface
        functions
        helps us design programs as well as modify them,
        because it allows us to maintain the flexibility to consider alternate
        implementations.  To continue with our simple example, suppose we are
        designing a rational-number package and we can&#146;t decide initially
        whether to perform the <span class="schemeinline">gcd</span> at construction time or at selection
        time.  The data-abstraction methodology gives us a way to defer that
        decision without losing the ability to make progress on the rest of
        the system.
      </div>

      <div class="exercise">
<b>Exercise 2.2.</b><a name="ex:segments1"></a>
        Consider the problem of representing 
        
        line segments in a plane.  Each segment is
        represented as a pair of points: a starting point and an ending point.
        Define a constructor 
        
        <span class="javascriptinline">make_segment</span> and selectors 
        
        <span class="javascriptinline">start_segment</span>
        and 
        
        <span class="javascriptinline">end_segment</span> that define the representation of segments in
        terms of points.  Furthermore, a point 
        
        can be represented as a pair
        of numbers: the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_674.png"></span> coordinate and the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_675.png"></span> coordinate.  Accordingly,
        specify a constructor 
        
        <span class="javascriptinline">make_point</span> and selectors <span class="javascriptinline">x_point</span> and
        <span class="javascriptinline">y_point</span> that define this representation.  Finally, using your
        selectors and constructors, define a
        function

        
        <span class="javascriptinline">midpoint_segment</span>
        that takes a line segment as argument and returns its midpoint (the
        point whose coordinates are the average of the coordinates of the
        endpoints).
        To try your
        functions, you&#146;ll need a way to print points:

        <div style="position:absolute;display:none;" id="javascript_376_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// make_segment, start_segment, end_segment,\n// make_point, x_point, and y_point to be\n// written by student\n          \nfunction print_point(p) {\n   newline();\n   display(&quot;(&quot; + x_point(p) +\n           &quot;,&quot; + y_point(p) +\n           &quot;)&quot;);\n}','javascript_376','',event,1.0);">function print_point(p) {
   newline();
   display("(" + x_point(p) +
           "," + y_point(p) +
           ")");
}</pre>
        
<div style="position:absolute;display:none;" id="javascript_378_div"></div>

</div>

      <div class="exercise">
<b>Exercise 2.3.</b>
        
        Implement a representation for rectangles in a plane.
        (Hint: You may want to make use of exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#ex:segments1">2.2</a>.)
        In terms of
        your constructors and selectors, create
        functions
        that compute the
        perimeter and the area of a given rectangle.  Now implement a
        different representation for rectangles.  Can you design your system
        with suitable abstraction barriers, so that the same perimeter and
        area
        functions
        will work using either representation?
        <a name="ex:rectangles"></a>
    <div style="position:absolute;display:none;" id="javascript_380_div"></div>
    
      </div>
      
    

    <h3><a name="subsection_2_1_3">2.1.3&nbsp;
        What Is Meant by Data?
      </a></h3>
      

      <a name="sec:data?"></a>
      
      <div class="normaltext">
        We began the rational-number implementation in
        section&nbsp;<a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#sec:rationals">2.1.1</a> by implementing the rational-number
        operations <span class="javascriptinline">add_rat</span>, <span class="javascriptinline">sub_rat</span>, and so on in terms of three
        unspecified
        functions: <span class="javascriptinline">make_rat</span>, <span class="schemeinline">numer</span>, and <span class="schemeinline">denom</span>.
        At that point, we could think of the operations as being defined in
        terms of data objects—numerators, denominators, and rational
        numbers—whose behavior was specified by the latter three
        functions.
      </div>

      <div class="normaltext">
        But exactly what is meant by <em>data</em>?  It is not enough to say
        &#147;whatever is implemented by the given selectors and constructors.&#148;
        Clearly, not every arbitrary set of three
        functions
        can serve as an
        appropriate basis for the rational-number implementation.  We need to
        guarantee that, 
        
        
        
        if we construct a rational number <span class="schemeinline">x</span> from a pair
        of integers <span class="schemeinline">n</span> and <span class="schemeinline">d</span>, then extracting the <span class="schemeinline">numer</span> and the
        <span class="schemeinline">denom</span> of <span class="schemeinline">x</span> and dividing them should yield the same result
        as dividing <span class="schemeinline">n</span> by <span class="schemeinline">d</span>. 
        In other words, <span class="javascriptinline">make_rat</span>,
        <span class="schemeinline">numer</span>, and <span class="schemeinline">denom</span> must satisfy the condition that, for any
        integer <span class="schemeinline">n</span> and any non-zero integer <span class="schemeinline">d</span>, if <span class="schemeinline">x</span> is
        <span class="javascriptinline">make_rat(n,d)</span>, then
	
        <P><img src="img_javascript/latex_44.png"></P>
	  
      </div>

      <div class="normaltext">
        In fact, this is the only condition <span class="javascriptinline">make_rat</span>, <span class="schemeinline">numer</span>, and
        <span class="schemeinline">denom</span> must fulfill in order to form a suitable basis for a
        rational-number representation.  In general, we can think of data as
        defined by some collection of selectors and constructors, together
        with specified conditions that these
        functions
        must fulfill in order
        to be a valid representation.<span style="vertical-align:3pt;font-size:0.75em"><a name="footnote_origin_4"><a class="link" href="#footnote_4">4</a></a></span>
      </div>

      <div class="normaltext">
        
          
          
          
        This point of view can serve to define not only &#147;high-level&#148; data
        objects, such as rational numbers, but lower-level objects as well.
        
            
          
        Consider the notion of a pair, which we used in order to define our
        rational numbers.  We never actually said what a pair was, only that
        the language supplied
        functions
        <span class="javascriptinline">pair</span>, <span class="javascriptinline">head</span>, and <span class="javascriptinline">tail</span>
        for operating on pairs.  But the only thing we need to know about
        these three operations 
        
        
        
        
        is that if we glue two objects together using
        <span class="javascriptinline">pair</span> we can retrieve the objects using <span class="javascriptinline">head</span> and <span class="javascriptinline">tail</span>.
        That is, the operations satisfy the condition that, for any objects
        <span class="schemeinline">x</span> and <span class="schemeinline">y</span>, if <span class="schemeinline">z</span> is <span class="javascriptinline">pair(x,y)</span> then <span class="javascriptinline">head(z)</span>
        is <span class="schemeinline">x</span> and <span class="javascriptinline">tail(x)</span> is <span class="schemeinline">y</span>.  Indeed, we mentioned that
        these three
        functions
        are included as primitives in our language.
        However, any triple of
        functions
        that satisfies the above condition
        can be used as the basis for implementing pairs.  This point is
        illustrated strikingly by the fact that we could implement <span class="javascriptinline">pair</span>,
        <span class="javascriptinline">head</span>, and <span class="javascriptinline">tail</span> without using any data structures at all but
        only using
        functions.  Here are the definitions:

        <div style="position:absolute;display:none;" id="javascript_382_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction pair(x,y) {\n   function dispatch(m) {\n      if (m === 0) return x;\n      else if (m === 1) return y;\n      else error(&quot;Argument not 0 or 1 -- pair &quot;,m);\n   }\n   return dispatch;\n}\nfunction head(z) {\n   return z(0);\n}\nfunction tail(z) {\n   return z(1);\n}\n\n// example\n\nvar x = pair(1,2);','javascript_382','',event,1.0);">function pair(x,y) {
   function dispatch(m) {
      if (m === 0) return x;
      else if (m === 1) return y;
      else error("Argument not 0 or 1 -- pair ",m);
   }
   return dispatch;
}
function head(z) {
   return z(0);
}
function tail(z) {
   return z(1);
}</pre>
      </div>

      <div class="normaltext">
        This use of
        functions
        corresponds to nothing like our intuitive
        notion of what data should be.  Nevertheless, all we need to do to
        show that this is a valid way to represent pairs is to verify that
        these
        functions
        satisfy the condition given above.
      </div>

      <div class="normaltext">
        The subtle point to notice is that the value returned by <span class="javascriptinline">pair(x,y)</span> is a
        function—namely the internally defined
        function
        <span class="schemeinline">dispatch</span>, which takes one argument and returns either <span class="schemeinline">x</span> or <span class="schemeinline">y</span> depending on whether the argument is 0 or 1.  Correspondingly, <span class="javascriptinline">head(z)</span> is defined to apply <span class="schemeinline">z</span> to 0.  Hence, if <span class="schemeinline">z</span> is the
        function
        formed by <span class="javascriptinline">pair(x,y)</span>, then <span class="schemeinline">z</span> applied to 0 will
        yield <span class="schemeinline">x</span>. Thus, we have shown that <span class="javascriptinline">head(pair(x,y))</span> yields
        <span class="schemeinline">x</span>, as desired.  Similarly, <span class="javascriptinline">tail(pair(x,y))</span> applies the
        function
        returned by <span class="javascriptinline">pair(x,y)</span> to 1, which returns <span class="schemeinline">y</span>.
        Therefore, this 
        
            functional
          
        implementation of pairs is a valid
        implementation, and if we access pairs using only <span class="javascriptinline">pair</span>, <span class="javascriptinline">head</span>, and <span class="javascriptinline">tail</span> we cannot distinguish this implementation from one
        that uses &#147;real&#148; data structures.
      </div>

      <div class="normaltext">
        The point of exhibiting the 
        
            functional
          
        representation of pairs is not
        that our language works this way 
        (we will be using arrays to represent pairs)
          
        but that it could
        work this way. The 
        
            functional
          
        representation, although obscure, is a
        perfectly adequate way to represent pairs, since it fulfills the only
        conditions that pairs need to fulfill.  This example also demonstrates
        that the ability to manipulate
        functions
        as objects automatically
        provides the ability to represent compound data.  This may seem a
        curiosity now, but 
        
            functional
          
        representations of data will play a
        central role in our programming repertoire.  This style of programming
        is often called 
        
        <em>message passing</em>, and we will be using it as a
        basic tool in chapter&nbsp;3 when we address the issues of modeling and
        simulation.
      </div>

      <div class="exercise">
<b>Exercise 2.4.</b> 
        Here is an alternative 
        
            functional
          
        representation of pairs.  For this
        representation, verify that <span class="javascriptinline">head(pair(x,y))</span> yields <span class="schemeinline">x</span> for
        any objects <span class="schemeinline">x</span> and <span class="schemeinline">y</span>.

        <div style="position:absolute;display:none;" id="javascript_383_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction pair(x,y) {\n   return function(m) { return m(x,y); }\n}\nfunction head(z) {\n   return z(function(p,q) { return p; });\n}\n\n// example\n\nvar x = pair(1,2);','javascript_383','',event,1.0);">function pair(x,y) {
   return function(m) { return m(x,y); }
}
function head(z) {
   return z(function(p,q) { return p; });
}</pre>

        
        
          

        What is the corresponding definition of <span class="javascriptinline">tail</span>? (Hint: To verify
        that this works, make use of the substitution model of
        section&nbsp;<a class="link" onclick="window.displayManager.show('section_1_1.html')" href="#sec:substitution-model">1.1.5</a>.)
        <a name="ex:lambda-cons"></a>
    <div style="position:absolute;display:none;" id="javascript_384_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.5.</b> 
        Show that we can represent pairs of nonnegative integers using only
        numbers and arithmetic operations if we represent the pair <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_676.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_677.png"></span>
        as the integer that is the product <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_678.png"></span>.  Give the corresponding
        definitions of the
        functions
        <span class="javascriptinline">pair</span>, <span class="javascriptinline">head</span>, and <span class="javascriptinline">tail</span>.

<div style="position:absolute;display:none;" id="javascript_385_div"></div>

</div>
        

          



      <div class="exercise">
<b>Exercise 2.6.</b> 
        In case representing pairs as
        functions
        wasn&#146;t mind-boggling enough,
        consider that, in a language that can manipulate
        functions, we can
        get by without numbers (at least insofar as nonnegative integers are
        concerned) by implementing 0 and the operation of adding 1 as

        <div style="position:absolute;display:none;" id="javascript_387_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nvar zero = function(f) { return function(x) { return x; }};\n\nfunction add_1(n) {\n   return function(f) {\n      return function(x) {\n         return f(n(f)(x));\n      }\n   }\n}\n\n// example\n\n','javascript_387','',event,1.0);">var zero = function(f) { return function(x) { return x; }};

function add_1(n) {
   return function(f) {
      return function(x) {
         return f(n(f)(x));
      }
   }
}</pre>

        This representation is known as 
        
        <em>Church numerals</em>, after its
        inventor, 
        
        Alonzo Church, the logician who invented the <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_679.png"></span>
        calculus.

        Define <span class="schemeinline">one</span> and <span class="schemeinline">two</span> directly (not in terms of <span class="schemeinline">zero</span>
        and <span class="javascriptinline">add_1</span>).  (Hint: Use substitution to evaluate <span class="javascriptinline">add_1(zero)</span>).
        Give a direct definition of the addition
        function
        <span class="schemeinline">+</span> (not in
        terms of repeated application of <span class="javascriptinline">add_1</span>).
        <a name="ex:church-numerals"></a>
    <div style="position:absolute;display:none;" id="javascript_388_div"></div>
      </div>

        
      
      
      
          


    

    <h3><a name="subsection_2_1_4">2.1.4&nbsp;
        Extended Exercise: Interval Arithmetic
      </a></h3>
      

      <a name="sec:interval-arith"></a>
      
      
      <div class="normaltext">
        Alyssa P. Hacker is designing a system to help people solve
        engineering problems.  One feature she wants to provide in her system
        is the ability to manipulate inexact quantities (such as measured
        parameters of physical devices) with known precision, so that when
        computations are done with such approximate quantities the results
        will be numbers of known precision.
      </div>

      <div class="normaltext">
        Electrical engineers will be using Alyssa&#146;s system to compute
        electrical quantities.  It is sometimes necessary for them to compute
        the value of a parallel equivalent resistance <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_680.png"></span> of two
        resistors <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_681.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_682.png"></span> using the formula
        

        <P><img src="img_javascript/latex_46.png"></P>
      </div>

      <div class="normaltext">
        Resistance values are usually known only up to some 
        
        tolerance
        guaranteed by the manufacturer of the resistor.  For example, if you
        buy a resistor labeled &#147;6.8 ohms with 10% tolerance&#148; you can only
        be sure that the resistor has a resistance between <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_683.png"></span> and
        <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_684.png"></span> ohms.  Thus, if you have a 6.8-ohm 10%&nbsp;resistor in
        parallel with a 4.7-ohm 5%&nbsp;resistor, the resistance of the
        combination can range from about 2.58 ohms (if the two resistors are
        at the lower bounds) to about 2.97 ohms (if the two resistors are at
        the upper bounds).
      </div>

      <div class="normaltext">
        Alyssa&#146;s idea is to implement &#147;interval arithmetic&#148; as a set of
        arithmetic operations for combining &#147;intervals&#148; (objects
        that represent the range of possible values of an inexact quantity).
        The result of adding, subtracting, multiplying, or dividing two
        intervals is itself an interval, representing the range of the
        result.
      </div>

      <div class="normaltext">
        Alyssa postulates the existence of an abstract object called an
        &#147;interval&#148; that has two endpoints: a lower bound and an upper bound.
        She also presumes that, given the endpoints of an interval, she can
        construct the interval using the data constructor 
        
        <span class="javascriptinline">make_interval</span>.
        Alyssa first writes a
        function
        for adding two intervals.  She
        reasons that the minimum value the sum could be is the sum of the two
        lower bounds and the maximum value it could be is the sum of the two
        upper bounds:

        <div style="position:absolute;display:none;" id="javascript_389_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// student needs to add upper_bound and lower_bound\nfunction make_interval(a,b) {\n   return pair(a,b);\n}\n          \nfunction add_interval(x,y) {\n   return make_interval(lower_bound(x) + lower_bound(y),\n                        upper_bound(x) + upper_bound(y));\n}\n\n// example\n\nadd_interval(make_interval(1,2),make_interval(3,5));','javascript_389','',event,1.0);">function add_interval(x,y) {
   return make_interval(lower_bound(x) + lower_bound(y),
                        upper_bound(x) + upper_bound(y));
}</pre>
      </div>

      <div class="normaltext">
        Alyssa also works out the product of two intervals by finding the
        minimum and the maximum of the products of the bounds and using them
        as the bounds of the resulting interval.  (<span class="javascriptinline">Math.min</span> and <span class="javascriptinline">Math.max</span> are
        
        
        
        
        primitives that find the minimum or maximum of any number of
        arguments.)

        <div style="position:absolute;display:none;" id="javascript_390_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// student needs to add upper_bound and lower_bound\nfunction make_interval(a,b) {\n   return pair(a,b);\n}\n          \nfunction mul_interval(x,y) {\n   var p1 = lower_bound(x) * lower_bound(y);\n   var p2 = lower_bound(x) * upper_bound(y);\n   var p3 = upper_bound(x) * lower_bound(y);\n   var p4 = upper_bound(x) * upper_bound(y);\n   return make_interval(Math.min(p1,p2,p3,p4),\n                        Math.max(p1,p2,p3,p4));\n}\n\n// example\n\nmul_interval(make_interval(1,2),make_interval(3,5));','javascript_390','',event,1.0);">function mul_interval(x,y) {
   var p1 = lower_bound(x) * lower_bound(y);
   var p2 = lower_bound(x) * upper_bound(y);
   var p3 = upper_bound(x) * lower_bound(y);
   var p4 = upper_bound(x) * upper_bound(y);
   return make_interval(Math.min(p1,p2,p3,p4),
                        Math.max(p1,p2,p3,p4));
}</pre>
      </div>

      <div class="normaltext">
        To divide two intervals, Alyssa multiplies the first by the reciprocal of
        the second.  Note that the bounds of the reciprocal interval are
        the reciprocal of the upper bound and the reciprocal of the lower bound, in
        that order.

        <div style="position:absolute;display:none;" id="javascript_391_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// student needs to add upper_bound and lower_bound\nfunction make_interval(a,b) {\n   return pair(a,b);\n}\n          \n// student needs to add upper_bound and lower_bound\nfunction make_interval(a,b) {\n   return pair(a,b);\n}\n          \nfunction mul_interval(x,y) {\n   var p1 = lower_bound(x) * lower_bound(y);\n   var p2 = lower_bound(x) * upper_bound(y);\n   var p3 = upper_bound(x) * lower_bound(y);\n   var p4 = upper_bound(x) * upper_bound(y);\n   return make_interval(Math.min(p1,p2,p3,p4),\n                        Math.max(p1,p2,p3,p4));\n}\n          \nfunction div_interval(x,y) {\n   return mul_interval(x,\n                       make_interval(1.0 / upper_bound(y),\n                                     1.0 / lower_bound(y)));\n}\n\n// example\n\ndiv_interval(make_interval(1,2),make_interval(3,5));','javascript_391','',event,1.0);">function div_interval(x,y) {
   return mul_interval(x,
                       make_interval(1.0 / upper_bound(y),
                                     1.0 / lower_bound(y)));
}</pre>
      </div>

      <div class="exercise">
<b>Exercise 2.7.</b> 
        Alyssa&#146;s program is incomplete because she has not specified the
        implementation of the interval abstraction.  Here is a definition of
        the interval constructor:

        <div style="position:absolute;display:none;" id="javascript_392_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// student needs to add upper_bound and lower_bound\nfunction make_interval(a,b) {\n   return pair(a,b);\n}','javascript_392','',event,1.0);">// student needs to add upper_bound and lower_bound
function make_interval(a,b) {
   return pair(a,b);
}</pre>

        

        

        

        Define selectors 
        
        <span class="javascriptinline">upper_bound</span> and 
        
        <span class="javascriptinline">lower_bound</span> to complete
        the implementation.
        <a name="ex:alyssa-interval-start"></a>

   <div style="position:absolute;display:none;" id="javascript_396_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.8.</b> 
        Using reasoning analogous to Alyssa&#146;s, describe how the difference
        of two intervals may be computed.  Define a corresponding subtraction
        function, called 
        
        <span class="javascriptinline">sub_interval</span>.
    <div style="position:absolute;display:none;" id="javascript_397_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.9.</b> 
        
        The <em>width</em> of an interval is half of the difference between its
        upper and lower bounds.  The width is a measure of the uncertainty of
        the number specified by the interval.  For some arithmetic operations
        the width of the result of combining two intervals is a function only
        of the widths of the argument intervals, whereas for others the width
        of the combination is not a function of the widths of the argument
        intervals.  Show that the width of the sum (or difference) of two
        intervals is a function only of the widths of the intervals being
        added (or subtracted).  Give examples to show that this is not true
        for multiplication or division.
        <div style="position:absolute;display:none;" id="javascript_398_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.10.</b>
        
        Ben Bitdiddle, an expert systems programmer, looks over Alyssa&#146;s
        shoulder and comments that it is not clear what it means to
        divide by an interval that spans zero.  Modify Alyssa&#146;s code to
        check for this condition and to signal an error if it occurs.
        <a name="ex:div-interval"></a>
<div style="position:absolute;display:none;" id="javascript_399_div"></div>
</div>
      <div class="exercise">
<b>Exercise 2.11.</b>
        
        In passing, Ben also cryptically comments: &#147;By testing the signs of
          the endpoints of the intervals, it is possible to break <span class="javascriptinline">mul_interval</span> into nine cases, only one of which requires more than
          two multiplications.&#148;  Rewrite this
        function
        using Ben&#146;s
        suggestion.
        <a name="ex:alyssa-interval-end"></a>
      </div>

      <div class="normaltext">
        After debugging her program, Alyssa shows it to a potential user,
        who complains that her program solves the wrong problem.  He
        wants a program that can deal with numbers represented as a center
        value and an additive tolerance; for example, he wants to work with
        intervals such as <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_685.png"></span> rather than <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_686.png"></span>.  
        Alyssa 
        returns to her desk and fixes this problem by supplying an alternate
        constructor and alternate selectors:

        <div style="position:absolute;display:none;" id="javascript_400_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// student needs to add upper_bound and lower_bound\nfunction make_interval(a,b) {\n   return pair(a,b);\n}\n          \nfunction make_center_width(c,w) {\n   return make_interval(c - w, c + w);\n}\nfunction center(i) {\n   return (lower_bound(i) + upper_bound(i)) / 2;\n}\nfunction width(i) {\n   return (upper_bound(i) - lower_bound(i)) / 2;\n}','javascript_400','',event,1.0);">function make_center_width(c,w) {
   return make_interval(c - w, c + w);
}
function center(i) {
   return (lower_bound(i) + upper_bound(i)) / 2;
}
function width(i) {
   return (upper_bound(i) - lower_bound(i)) / 2;
}</pre>

        Unfortunately, most of Alyssa&#146;s users are engineers.  Real engineering
        situations usually involve measurements with only a small uncertainty,
        measured as the ratio of the width of the interval to the midpoint of
        the interval.  Engineers usually specify percentage tolerances on the
        parameters of devices, as in the resistor specifications given
        earlier.
      </div>

      <div class="exercise">
<b>Exercise 2.12.</b>
        Define a constructor 
        
        <span class="javascriptinline">make_center_percent</span> that takes a center and
        a percentage tolerance and produces the desired interval.  You must
        also define a selector <span class="schemeinline">percent</span> that produces the
        percentage tolerance for a given interval.  The <span class="schemeinline">center</span> selector
        is the same as the one shown above.
        <a name="ex:make-center-percent"></a>
    <div style="position:absolute;display:none;" id="javascript_401_div"></div>
      </div>

      <div class="exercise">
<b>Exercise 2.13.</b> 
        Show that under the assumption of small percentage tolerances there is
        a simple formula for the approximate percentage tolerance of the
        product of two intervals in terms of the tolerances of the factors.
        You may simplify the problem by assuming that all numbers are
        positive.
        <a name="ex:interval-product"></a>
    <div style="position:absolute;display:none;" id="javascript_402_div"></div>
      </div>

      <div class="normaltext">
        After considerable work, Alyssa P. Hacker delivers her finished
        system.  Several years later, after she has forgotten all about it, she
        gets a frenzied call from an irate user,  Lem E. Tweakit.
        It seems that Lem has
        noticed that the formula for parallel resistors can be written in two
        
        algebraically equivalent ways:

        <P><img src="img_javascript/latex_47.png"></P>


        and

        <P><img src="img_javascript/latex_48.png"></P>


        He has written the following two programs, each of which computes the
        parallel-resistors formula differently:

        <div style="position:absolute;display:none;" id="javascript_403_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\n// student needs to add upper_bound and lower_bound\nfunction make_interval(a,b) {\n   return pair(a,b);\n}\n          \nfunction add_interval(x,y) {\n   return make_interval(lower_bound(x) + lower_bound(y),\n                        upper_bound(x) + upper_bound(y));\n}\n          \n// student needs to add upper_bound and lower_bound\nfunction make_interval(a,b) {\n   return pair(a,b);\n}\n          \nfunction mul_interval(x,y) {\n   var p1 = lower_bound(x) * lower_bound(y);\n   var p2 = lower_bound(x) * upper_bound(y);\n   var p3 = upper_bound(x) * lower_bound(y);\n   var p4 = upper_bound(x) * upper_bound(y);\n   return make_interval(Math.min(p1,p2,p3,p4),\n                        Math.max(p1,p2,p3,p4));\n}\n          \n// student needs to add upper_bound and lower_bound\nfunction make_interval(a,b) {\n   return pair(a,b);\n}\n          \n// student needs to add upper_bound and lower_bound\nfunction make_interval(a,b) {\n   return pair(a,b);\n}\n          \nfunction mul_interval(x,y) {\n   var p1 = lower_bound(x) * lower_bound(y);\n   var p2 = lower_bound(x) * upper_bound(y);\n   var p3 = upper_bound(x) * lower_bound(y);\n   var p4 = upper_bound(x) * upper_bound(y);\n   return make_interval(Math.min(p1,p2,p3,p4),\n                        Math.max(p1,p2,p3,p4));\n}\n          \nfunction div_interval(x,y) {\n   return mul_interval(x,\n                       make_interval(1.0 / upper_bound(y),\n                                     1.0 / lower_bound(y)));\n}\n          \nfunction par1(r1,r2) {\n   return div_interval(mul_interval(r1,r2),\n                       add_interval(r1,r2));\n}\nfunction par2(r1,r2) {\n   var one = make_interval(1,1);\n   return div_interval(one,\n                       add_interval(div_interval(one,r1),\n                                    div_interval(one,r2)));\n}','javascript_403','',event,1.0);">function par1(r1,r2) {
   return div_interval(mul_interval(r1,r2),
                       add_interval(r1,r2));
}
function par2(r1,r2) {
   var one = make_interval(1,1);
   return div_interval(one,
                       add_interval(div_interval(one,r1),
                                    div_interval(one,r2)));
}</pre>

        Lem complains that Alyssa&#146;s program gives different answers for
        the two ways of computing. This is a serious complaint.
      </div>

      <div class="exercise">
<b>Exercise 2.14.</b> 
        Demonstrate that Lem is right. Investigate the behavior of the
        system on a variety of arithmetic expressions. Make some intervals <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_687.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_688.png"></span>,
        and use them in computing the expressions <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_689.png"></span> and <span style="vertical-align:-3pt"><img src="img_javascript/latex_inline_690.png"></span>.  You will
        get the most insight by using intervals whose width is a small
        percentage of the center value. Examine the results of the computation
        in center-percent form (see exercise&nbsp;<a class="link" onclick="window.displayManager.show('section_2_1.html')" href="#ex:make-center-percent">2.12</a>).
        <a name="ex:interval-compare"></a>
      </div>

      <div class="exercise">
<b>Exercise 2.15.</b>
        Eva Lu Ator, another user, has also noticed the different intervals
        computed by different but algebraically equivalent expressions. She
        says that a formula to compute with intervals using Alyssa&#146;s system
        will produce tighter error bounds if it can be written in such a form
        that no variable that represents an uncertain number is repeated.
        Thus, she says, <span class="schemeinline">par2</span> is a &#147;better&#148; program for parallel
        resistances than <span class="schemeinline">par1</span>.  Is she right?  Why?
      </div>

      <div class="exercise">
<b>Exercise 2.16.</b>
        Explain, in general, why equivalent algebraic expressions may lead to
        different answers.  Can you devise an interval-arithmetic package that
        does not have this shortcoming, or is this task impossible?  (Warning:
        This problem is very difficult.)
      </div>
      
      
    
  <div class="navbar" align="center">
<hr>&nbsp;&nbsp;&nbsp;<a class="link" onclick="window.displayManager.show('chapter_2.html')">this chapter</a>&nbsp;&nbsp;&nbsp;<a class="link" onclick="window.displayManager.show('section_2_2.html')">next section</a><hr>
</div><strong class="footnote">Footnotes</strong><div class="footnote">
<a name="footnote_2"><sup><a class="link" href="#footnote_origin_2">2</a></sup></a>
            Another way to define the selectors and constructor is
        <div style="position:absolute;display:none;" id="javascript_362_div"></div>
<pre class="jush-js" title="evaluate JavaScript expression" onClick="new window.JavascriptConsole('\nfunction make_rat(n,d) {\n   return pair(n,d);\n}\nfunction numer(x) {\n   return head(x);\n}\nfunction denom(x) {\n   return tail(x);\n}','javascript_362','',event,1.0);">function make_rat(n,d) {
   return pair(n,d);
}
function numer(x) {
   return head(x);
}
function denom(x) {
   return tail(x);
}</pre>
          The first definition associates the name <span class="javascriptinline">make_rat</span>
          with the value of the expression <span class="javascriptinline">pair</span>, which is the primitive
          function
          that constructs pairs.  Thus <span class="javascriptinline">make_rat</span> and <span class="javascriptinline">pair</span>
          are names for the same primitive constructor.
          <p>
          Defining selectors and constructors in this way is efficient:
          Instead of <span class="javascriptinline">make_rat</span> <em>calling</em> <span class="javascriptinline">pair</span>, <span class="javascriptinline">make_rat</span>
          <em>is</em> <span class="javascriptinline">pair</span>, so there is only one
          function
          called, not two,
          when <span class="javascriptinline">make_rat</span> is called.  On the other hand, doing this defeats debugging
          aids that trace
          function
          calls or put breakpoints on
          function
          calls:
          You may want to watch <span class="javascriptinline">make_rat</span> being called, but you certainly
          don&#146;t want to watch every call to <span class="javascriptinline">pair</span>.
          </p>
          <p>
          We have chosen not to use this style of definition in this
          book.<a name="foot:proc-def-style"></a>
          </p>
        </div><div class="footnote">
<a name="footnote_3"><sup><a class="link" href="#footnote_origin_3">3</a></sup></a>
          
          
          
          
          
          <span class="schemeinline">Display</span> is
          the Scheme primitive for printing data.  The Scheme primitive
          <span class="schemeinline">newline</span> starts a new line for printing.
          
          
          Neither of these
          functions
          returns a useful value, so in the uses of
          <span class="javascriptinline">print_rat</span> below, we show only what <span class="javascriptinline">print_rat</span> prints,
          not what the interpreter prints as the value returned by <span class="javascriptinline">print_rat</span>.</div><div class="footnote">
<a name="footnote_4"><sup><a class="link" href="#footnote_origin_4">4</a></sup></a>Surprisingly, this idea is very
          difficult to formulate rigorously. There are two approaches to giving
          such a formulation.  One, pioneered by 
          
          C. A. R. Hoare (1972), is known
          as the method of 
          
          
          <em>abstract models</em>.  It formalizes the
          &#147;functions
            plus conditions&#148; specification as outlined in the
          rational-number example above.  Note that the condition on the
          rational-number representation was stated in terms of facts about
          integers (equality and division).  In general, abstract models define
          new kinds of data objects in terms of previously defined types of data
          objects.  Assertions about data objects can therefore be checked by
          reducing them to assertions about previously defined data objects.
          Another approach, introduced by 
          
          Zilles at MIT, by 
          
          Goguen, 
          
          Thatcher,
          
          Wagner, and 
          
          Wright at IBM (see Thatcher, Wagner, and Wright 1978), and by 
          
          Guttag at Toronto (see Guttag 1977),
          is called 
          
          
          <em>algebraic specification</em>.  It regards the &#147;functions&#148;
          as elements of an abstract algebraic system whose behavior is
          specified by axioms that correspond to our &#147;conditions,&#148; and uses
          the techniques of abstract algebra to check assertions about data
          objects.  Both methods are surveyed in the paper by 
          
          Liskov and Zilles
          (1975).</div>
